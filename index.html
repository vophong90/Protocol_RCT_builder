<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>Wizard ƒê·ªÅ c∆∞∆°ng RCT</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <script> pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script>mermaid.initialize({ startOnLoad: false });</script>

  <style>
    body { font-family: Arial; padding: 20px; }
    .step { display: none; }
    .step.active { display: block; }
    .steps-nav { display: flex; gap: 10px; margin-bottom: 20px; }
    .steps-nav button {
      padding: 8px 12px;
      border: none;
      background-color: #ddd;
      cursor: pointer;
    }
    .steps-nav button.active {
      background-color: #4CAF50;
      color: white;
    }
    textarea, input[type="text"] {
      width: 100%;
      margin-top: 5px;
      margin-bottom: 10px;
      padding: 6px;
    }
  .gpt-suggest, .gpt-eval {
    white-space: pre-wrap;
    padding: 10px;
    border: 1px solid #ccc;
    margin-top: 5px;
  }
  .gpt-suggest { background: #eef; }
  .gpt-eval { background: #efe; }

  #variable-groups {
    display: flex;
    flex-direction: column;
    gap: 20px;
    margin-top: 20px;
  }
  .variable-group {
    display: flex;
    flex-direction: column;
    border: 1px solid #ccc;
    padding: 10px;
    border-radius: 8px;
  }
  .variable-group h4 {
    margin: 0;
  }
  .variable-group .description {
    font-style: italic;
    margin-bottom: 10px;
  }
  .variable-lists {
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
  }
  .variable-list {
    flex: 1;
    min-width: 250px;
    min-height: 150px;
    border: 1px dashed #999;
    padding: 10px;
    border-radius: 6px;
    background: #fafafa;
  }
  .variable-list li {
  position: relative;
  padding: 4px 8px;
  padding-right: 40px;
  background: #eee;
  border: 1px solid #ccc;
  border-radius: 4px;
  margin-bottom: 6px;
  cursor: grab;
  min-height: 32px;
  line-height: 20px;
  overflow: visible;
}

 .variable-list li button {
  position: absolute;
  top: 4px;
  right: 6px;
  background: none;
  border: none;
  color: red;
  cursor: pointer;
  font-size: 16px;
  z-index: 2;
}


  .collection-block {
    border: 1px solid #ccc;
    padding: 15px;
    margin: 15px 0;
    border-radius: 6px;
    background-color: #f9f9f9;
  }

  .collection-block label {
    font-weight: bold;
    margin-top: 10px;
    display: block;
  }

  .collection-block input,
  .collection-block textarea {
    width: 100%;
    margin-bottom: 10px;
    padding: 6px;
    box-sizing: border-box;
  }
  .analysis-block {
    border: 1px solid #ccc;
    padding: 15px;
    margin: 15px 0;
    border-radius: 6px;
    background-color: #f9f9f9;
  }

  .analysis-block label {
    font-weight: bold;
    margin-top: 10px;
    display: block;
  }

  .analysis-block input,
  .analysis-block textarea {
    width: 100%;
    margin-bottom: 10px;
    padding: 6px;
    box-sizing: border-box;
  }
  #step-11 input,
  #step-11 textarea {
    width: 100%;
    margin-bottom: 10px;
    padding: 6px;
    box-sizing: border-box;
  }

  #step-11 label {
    font-weight: bold;
    margin-top: 10px;
    display: block;
  }
 input[type="text"], input[type="number"], select, textarea {
  border: 1px solid #ccc;
  border-radius: 6px;
  padding: 10px;
  font-size: 15px;
  font-family: 'Segoe UI', 'Roboto', sans-serif;
  background-color: #fff;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  transition: border-color 0.2s, box-shadow 0.2s;
 }

 input[type="text"]:focus, input[type="number"]:focus,
  select:focus, textarea:focus {
  border-color: #4CAF50;
  outline: none;
  box-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
 }

</style>
</head>
<body>

  <h1>X√¢y d·ª±ng ƒë·ªÅ c∆∞∆°ng RCT ‚Äì Wizard Demo</h1>

  <!-- Thanh ƒëi·ªÅu h∆∞·ªõng -->
  <div class="steps-nav">
    <button onclick="goToStep(0)" id="nav-0">1. PICO</button>
    <button onclick="goToStep(1)" id="nav-1">2. C√¢u h·ªèi</button>
    <button onclick="goToStep(2)" id="nav-2">3. M·ª•c ti√™u</button>
    <button onclick="goToStep(3)" id="nav-3">4. M·ªü ƒë·∫ßu</button>
    <button onclick="goToStep(4)" id="nav-4">5. T·ªïng quan</button>
    <button onclick="goToStep(5)" id="nav-5">6. Thi·∫øt k·∫ø</button>
    <button onclick="goToStep(6)" id="nav-6">7. C·ª° m·∫´u</button>
    <button onclick="goToStep(7)" id="nav-7">8. Ti√™u ch√≠</button>
    <button onclick="goToStep(8)" id="nav-8">9. Ng·∫´u nhi√™n</button>
    <button onclick="goToStep(9)" id="nav-9">10. Can thi·ªáp</button>
    <button onclick="goToStep(10)" id="nav-10">11. Bi·∫øn s·ªë</button>
    <button onclick="goToStep(11)" id="nav-11">12. Thu th·∫≠p</button>
    <button onclick="goToStep(12)" id="nav-12">13. Ph√¢n t√≠ch</button>
    <button onclick="goToStep(13)" id="nav-13">14. ƒê·∫°o ƒë·ª©c</button>
    <button onclick="goToStep(14)" id="nav-14">15. Check logic</button>
    <button onclick="goToStep(15)" id="nav-15">16. S∆° ƒë·ªì</button>
  </div>

  <!-- B∆∞·ªõc 1: PICO -->
  <div class="step" id="step-0">
    <h2>B∆∞·ªõc 1: PICO</h2>
    <label>P - D√¢n s·ªë m·ª•c ti√™u:</label>
    <input type="text" id="pico-p" oninput="saveData()">

    <label>I - Can thi·ªáp:</label>
    <input type="text" id="pico-i" oninput="saveData()">

    <label>C - So s√°nh:</label>
    <input type="text" id="pico-c" oninput="saveData()">
  
    <label>O - K·∫øt c·ª•c:</label>
    <input type="text" id="pico-o" oninput="saveData()">
    <br>
    <h3>K·∫øt qu·∫£ t·ª´ GPT:</h3>
    <label>üìÇ T·∫£i t√†i li·ªáu PDF h·ªó tr·ª£ (n·∫øu c√≥):</label>
    <input type="file" id="pico-file" accept=".pdf" multiple><br><br>
    <button onclick="generatePicoDescription()">üß† GPT vi·∫øt m√¥ t·∫£ t·ª´ PICO</button>
    <div id="pico-gpt-result" style="white-space: pre-wrap; background: #f4f4f4; padding: 10px; border: 1px solid #ccc;"></div>
    <br>
    <button disabled>‚¨ÖÔ∏è</button>
    <button onclick="goToStep(1)">Ti·∫øp ‚û°Ô∏è</button>
    <br><br>
    <button onclick="resetWizard()" style="margin-bottom:20px; background:red; color:white; padding:8px 12px; border:none; border-radius:6px; cursor:pointer;">üóë X√≥a to√†n b·ªô d·ªØ li·ªáu v√† b·∫Øt ƒë·∫ßu l·∫°i</button>
  </div>

  <!-- B∆∞·ªõc 2: C√¢u h·ªèi nghi√™n c·ª©u -->
  <div class="step" id="step-1">
    <h2>B∆∞·ªõc 2: C√¢u h·ªèi nghi√™n c·ª©u</h2>
    <label for="question">Nh·∫≠p c√¢u h·ªèi:</label>
    <textarea id="question" oninput="saveData()"></textarea><br><br>
    <h3>K·∫øt qu·∫£ t·ª´ GPT:</h3>
    <label>üìÇ T·∫£i t√†i li·ªáu PDF h·ªó tr·ª£ (n·∫øu c√≥):</label>
    <input type="file" id="question-file" accept=".pdf" multiple><br>
    <button onclick="generateResearchQuestionFromGPT()">üß† GPT g·ª£i √Ω c√¢u h·ªèi t·ª´ t√†i li·ªáu</button>
    <div id="question-gpt-suggestion" style="white-space: pre-wrap; background: #eef; padding: 10px; border: 1px solid #99c;"></div>
    <button onclick="evaluateResearchQuestion()">üßê GPT ƒë√°nh gi√° c√¢u h·ªèi</button>
    <div id="question-gpt-evaluation" style="white-space: pre-wrap; background: #efe; padding: 10px; border: 1px solid #9c9;"></div>
    
    <br><br>
    <button onclick="goToStep(0)">‚¨ÖÔ∏è Quay l·∫°i</button>
    <button onclick="goToStep(2)">Ti·∫øp ‚û°Ô∏è</button>
  </div>

  <!-- B∆∞·ªõc 3: M·ª•c ti√™u nghi√™n c·ª©u -->
  <div class="step" id="step-2">
    <h2>B∆∞·ªõc 3: M·ª•c ti√™u nghi√™n c·ª©u</h2>

    <label>M·ª•c ti√™u ch√≠nh:</label>
    <input type="text" id="main-objective" oninput="saveData()">
    
    <label>M·ª•c ti√™u ph·ª•:</label>
    <div id="sub-objectives"></div>
    <button onclick="addSubObjective()">‚ûï Th√™m m·ª•c ti√™u ph·ª•</button>
    <br><br>
    <h3>K·∫øt qu·∫£ t·ª´ GPT:</h3>
    <label>üìÇ T·∫£i t√†i li·ªáu PDF h·ªó tr·ª£ (n·∫øu c√≥):</label>
    <input type="file" id="objective-file" accept=".pdf" multiple><br>
    <button onclick="generateObjectivesFromGPT()">üß† GPT g·ª£i √Ω m·ª•c ti√™u t·ª´ t√†i li·ªáu</button>
    <div id="objective-gpt-suggestion" style="white-space: pre-wrap; background: #eef; padding: 10px; border: 1px solid #99c;"></div>
    <button onclick="evaluateObjectives()">üßê GPT ƒë√°nh gi√° m·ª•c ti√™u hi·ªán t·∫°i</button>
    <div id="objective-gpt-evaluation" style="white-space: pre-wrap; background: #efe; padding: 10px; border: 1px solid #9c9;"></div>
    <br>
    <button onclick="goToStep(1)">‚¨ÖÔ∏è Quay l·∫°i</button>
    <button onclick="goToStep(3)">Ti·∫øp ‚û°Ô∏è</button>
  </div>

<!-- B∆∞·ªõc 4: M·ªü ƒë·∫ßu - theo CaRS, t√°ch 3 ph·∫ßn -->
<div class="step" id="step-3">
  <h2>B∆∞·ªõc 4: M·ªü ƒë·∫ßu (CaRS)</h2>

  <!-- TERRITORY -->
  <h3>1. Territory - B·ªëi c·∫£nh nghi√™n c·ª©u</h3>
  <label>T·∫£i t√†i li·ªáu PDF h·ªó tr·ª£ (n·∫øu c√≥):</label>
  <input type="file" id="file-territory" accept=".pdf">
  <br>
  <label>Nh·∫≠p n·ªôi dung Territory:</label>
  <textarea id="intro-territory" rows="5" style="width:100%"></textarea>
  <br>
  <button onclick="generateGPT_Territory()">üß† GPT g·ª£i √Ω Territory</button>
  <div id="suggest-territory" style="white-space: pre-wrap; background: #eef; padding: 10px; border: 1px solid #99c;"></div>
  <button onclick="evaluateGPT_Territory()">üßê GPT ƒë√°nh gi√° Territory</button>
  <div id="eval-territory" style="white-space: pre-wrap; background: #efe; padding: 10px; border: 1px solid #9c9;"></div>

  <!-- NICHE -->
  <h3>2. Niche - Kho·∫£ng tr·ªëng ki·∫øn th·ª©c</h3>
  <label>T·∫£i t√†i li·ªáu PDF h·ªó tr·ª£ (n·∫øu c√≥):</label>
  <input type="file" id="file-niche" accept=".pdf">
  <br>
  <label>Nh·∫≠p n·ªôi dung Niche:</label>
  <textarea id="intro-niche" rows="5" style="width:100%"></textarea>
  <br>
  <button onclick="generateGPT_Niche()">üß† GPT g·ª£i √Ω Niche</button>  
  <div id="suggest-niche" style="white-space: pre-wrap; background: #eef; padding: 10px; border: 1px solid #99c;"></div>
  <button onclick="evaluateGPT_Niche()">üßê GPT ƒë√°nh gi√° Niche</button>
  <div id="eval-niche" style="white-space: pre-wrap; background: #efe; padding: 10px; border: 1px solid #9c9;"></div>

  <!-- OCCUPY -->
  <h3>3. Occupy - C√°ch nghi√™n c·ª©u chi·∫øm lƒ©nh kho·∫£ng tr·ªëng</h3>
  <label>T·∫£i t√†i li·ªáu PDF h·ªó tr·ª£ (n·∫øu c√≥):</label>
  <input type="file" id="file-occupy" accept=".pdf">
  <br>
  <label>Nh·∫≠p n·ªôi dung Occupy:</label>
  <textarea id="intro-occupy" rows="5" style="width:100%"></textarea>
  <br>
  <button onclick="generateGPT_Occupy()">üß† GPT g·ª£i √Ω Occupy</button>
  <div id="suggest-occupy" style="white-space: pre-wrap; background: #eef; padding: 10px; border: 1px solid #99c;"></div>
  <button onclick="evaluateGPT_Occupy()">üßê GPT ƒë√°nh gi√° Occupy</button>
  <div id="eval-occupy" style="white-space: pre-wrap; background: #efe; padding: 10px; border: 1px solid #9c9;"></div>

  <br>
  <button onclick="goToStep(2)">‚¨ÖÔ∏è Quay l·∫°i</button>
  <button onclick="goToStep(4)">Ti·∫øp ‚û°Ô∏è</button>
</div>

<!-- B∆∞·ªõc 5: T·ªïng quan t√†i li·ªáu -->
<div class="step" id="step-4">
  <h2>B∆∞·ªõc 5: T·ªïng quan t√†i li·ªáu</h2>

  <!-- 1. ƒê·∫°i c∆∞∆°ng YHHƒê -->
  <h3>1. ƒê·∫°i c∆∞∆°ng YHHƒê</h3>
  <input type="file" id="file-yhhd-overview" accept=".pdf">
  <textarea id="text-yhhd-overview" rows="5" style="width:100%"></textarea>
  <button onclick="generateGPT_YHHD_Overview()">üß† GPT g·ª£i √Ω</button>
  <div id="suggest-yhhd-overview" class="gpt-suggest"></div>
  <button onclick="evaluateGPT_YHHD_Overview()">üßê GPT ƒë√°nh gi√°</button>
  <div id="eval-yhhd-overview" class="gpt-eval"></div>

  <!-- 2. D·ªãch t·ªÖ h·ªçc v√† g√°nh n·∫∑ng b·ªánh t·∫≠t -->
  <h3>2. D·ªãch t·ªÖ h·ªçc v√† g√°nh n·∫∑ng b·ªánh t·∫≠t</h3>
  <input type="file" id="file-epidemiology" accept=".pdf">
  <textarea id="text-epidemiology" rows="5" style="width:100%"></textarea>
  <button onclick="generateGPT_Epidemiology()">üß† GPT g·ª£i √Ω</button>
  <div id="suggest-epidemiology" class="gpt-suggest"></div>
  <button onclick="evaluateGPT_Epidemiology()">üßê GPT ƒë√°nh gi√°</button>
  <div id="eval-epidemiology" class="gpt-eval"></div>

  <!-- 3. Ch·∫©n ƒëo√°n YHHƒê -->
  <h3>3. Ch·∫©n ƒëo√°n YHHƒê</h3>
  <input type="file" id="file-diagnosis" accept=".pdf">
  <textarea id="text-diagnosis" rows="5" style="width:100%"></textarea>
  <button onclick="generateGPT_Diagnosis()">üß† GPT g·ª£i √Ω</button>
  <div id="suggest-diagnosis" class="gpt-suggest"></div>
  <button onclick="evaluateGPT_Diagnosis()">üßê GPT ƒë√°nh gi√°</button>
  <div id="eval-diagnosis" class="gpt-eval"></div>

  <!-- 4. ƒêi·ªÅu tr·ªã YHHƒê -->
  <h3>4. ƒêi·ªÅu tr·ªã YHHƒê</h3>
  <input type="file" id="file-treatment" accept=".pdf">
  <textarea id="text-treatment" rows="5" style="width:100%"></textarea>
  <button onclick="generateGPT_Treatment()">üß† GPT g·ª£i √Ω</button>
  <div id="suggest-treatment" class="gpt-suggest"></div>
  <button onclick="evaluateGPT_Treatment()">üßê GPT ƒë√°nh gi√°</button>
  <div id="eval-treatment" class="gpt-eval"></div>

  <!-- 5. H·∫°n ch·∫ø c·ªßa YHHƒê -->
  <h3>5. H·∫°n ch·∫ø c·ªßa YHHƒê trong qu·∫£n l√Ω t√¨nh tr·∫°ng/b·ªánh</h3>
  <input type="file" id="file-limitation" accept=".pdf">
  <textarea id="text-limitation" rows="5" style="width:100%"></textarea>
  <button onclick="generateGPT_Limitation()">üß† GPT g·ª£i √Ω</button>
  <div id="suggest-limitation" class="gpt-suggest"></div>
  <button onclick="evaluateGPT_Limitation()">üßê GPT ƒë√°nh gi√°</button>
  <div id="eval-limitation" class="gpt-eval"></div>

  <!-- 6. ƒê·∫°i c∆∞∆°ng YHCT -->
  <h3>6. ƒê·∫°i c∆∞∆°ng YHCT</h3>
  <input type="file" id="file-yhct-overview" accept=".pdf">
  <textarea id="text-yhct-overview" rows="5" style="width:100%"></textarea>
  <button onclick="generateGPT_YHCT_Overview()">üß† GPT g·ª£i √Ω</button>
  <div id="suggest-yhct-overview" class="gpt-suggest"></div>
  <button onclick="evaluateGPT_YHCT_Overview()">üßê GPT ƒë√°nh gi√°</button>
  <div id="eval-yhct-overview" class="gpt-eval"></div>

  <!-- 7. Li·ªáu ph√°p can thi·ªáp trong nghi√™n c·ª©u -->
  <h3>7. Li·ªáu ph√°p can thi·ªáp trong nghi√™n c·ª©u</h3>
  <input type="file" id="file-intervention" accept=".pdf">
  <textarea id="text-intervention" rows="5" style="width:100%"></textarea>
  <button onclick="generateGPT_Intervention()">üß† GPT g·ª£i √Ω</button>
  <div id="suggest-intervention" class="gpt-suggest"></div>
  <button onclick="evaluateGPT_Intervention()">üßê GPT ƒë√°nh gi√°</button>
  <div id="eval-intervention" class="gpt-eval"></div>

  <!-- 8. C√°c nghi√™n c·ª©u c√πng lo·∫°i trong & ngo√†i n∆∞·ªõc -->
  <h3>8. C√°c nghi√™n c·ª©u c√πng lo·∫°i trong & ngo√†i n∆∞·ªõc</h3>
  <input type="file" id="file-related-studies" accept=".pdf">
  <textarea id="text-related-studies" rows="5" style="width:100%"></textarea>
  <button onclick="generateGPT_RelatedStudies()">üß† GPT g·ª£i √Ω</button>
  <div id="suggest-related-studies" class="gpt-suggest"></div>
  <button onclick="evaluateGPT_RelatedStudies()">üßê GPT ƒë√°nh gi√°</button>
  <div id="eval-related-studies" class="gpt-eval"></div>

  <!-- 9. C√°c ph∆∞∆°ng ph√°p m·ªõi ph√¢n t√≠ch/d·ªØ li·ªáu -->
  <h3>9. C√°c ph∆∞∆°ng ph√°p m·ªõi trong ph√¢n t√≠ch s·ªë li·ªáu hay ƒë√°nh gi√° s·ªë li·ªáu</h3>
  <input type="file" id="file-new-methods" accept=".pdf">
  <textarea id="text-new-methods" rows="5" style="width:100%"></textarea>
  <button onclick="generateGPT_NewMethods()">üß† GPT g·ª£i √Ω</button>
  <div id="suggest-new-methods" class="gpt-suggest"></div>
  <button onclick="evaluateGPT_NewMethods()">üßê GPT ƒë√°nh gi√°</button>
  <div id="eval-new-methods" class="gpt-eval"></div>

  <br><br>
  <button onclick="goToStep(3)">‚¨ÖÔ∏è Quay l·∫°i</button>
  <button onclick="goToStep(5)">Ti·∫øp ‚û°Ô∏è</button>
</div>

<!-- B∆∞·ªõc 6: Thi·∫øt k·∫ø nghi√™n c·ª©u -->
<div class="step" id="step-5">
  <h2>B∆∞·ªõc 6: Thi·∫øt k·∫ø nghi√™n c·ª©u</h2>

  <label>üìò Lo·∫°i RCT:</label>
  <select id="design-type" onchange="updateDesignFields(); saveData(); renderStudyFlowDiagram()">
    <option value="">-- ch·ªçn --</option>
    <option value="parallel">Song song</option>
    <option value="cross-over">B·∫Øt ch√©o (cross-over)</option>
  </select>

  <label>üé≤ Ph√¢n b·ªï ng·∫´u nhi√™n:</label>
  <select id="randomization" onchange="saveData()">
    <option value="">-- ch·ªçn --</option>
    <option>Ng·∫´u nhi√™n ƒë∆°n gi·∫£n</option>
    <option>Ng·∫´u nhi√™n ph√¢n t·∫ßng</option>
    <option>Ng·∫´u nhi√™n block</option>
  </select>

  <label>üôà L√†m m√π:</label>
  <select id="blinding" onchange="saveData()">
    <option value="">-- ch·ªçn --</option>
    <option>Kh√¥ng m√π</option>
    <option>L√†m m√π ƒë∆°n</option>
    <option>L√†m m√π ƒë√¥i</option>
    <option>L√†m m√π ba</option>
  </select>
  <br><br>
  <!-- Kh·ªëi xu·∫•t hi·ªán t√πy theo lo·∫°i thi·∫øt k·∫ø -->
  <div id="design-extra-fields" style="margin-top: 15px;"></div>
  
  <h3>K·∫øt qu·∫£ t·ª´ GPT:</h3>
  <label>üìÇ T·∫£i t√†i li·ªáu PDF h·ªó tr·ª£ (n·∫øu c√≥):</label>
  <input type="file" id="file-design" accept="application/pdf"><br>
  <button onclick="generateGPT_Design()">üß† GPT g·ª£i √Ω</button>
  <div id="suggest-design" class="gpt-suggest"></div>
  <button onclick="evaluateGPT_Design()">üßê GPT ƒë√°nh gi√°</button>
  <div id="eval-design" class="gpt-eval"></div>
  <br><br>
  <button onclick="goToStep(4)">‚¨ÖÔ∏è Quay l·∫°i</button>
  <button onclick="goToStep(6)">Ti·∫øp ‚û°Ô∏è</button>
</div>

<!-- B∆∞·ªõc 7: T√≠nh c·ª° m·∫´u -->
<div class="step" id="step-6">
  <h2>B∆∞·ªõc 7: T√≠nh c·ª° m·∫´u</h2>

  <label>Ch·ªçn lo·∫°i c√¥ng th·ª©c:</label>
  <select id="sample-size-method" onchange="renderSampleSizeForm()">
    <option value="">-- Ch·ªçn c√¥ng th·ª©c --</option>
    <option value="means">So s√°nh 2 trung b√¨nh</option>
    <option value="noninferiority_means">Th·ª≠ nghi·ªám kh√¥ng h∆°n k√©m (2 trung b√¨nh)</option>
    <option value="crossover_means">So s√°nh trung b√¨nh (b·∫Øt ch√©o)</option>
    <option value="proportions">So s√°nh 2 t·ª∑ l·ªá</option>
    <option value="noninferiority_prop"> Th·ª≠ nghi·ªám kh√¥ng h∆°n k√©m (2 t·ª∑ l·ªá)</option>
    <option value="crossover_props">So s√°nh t·ª∑ l·ªá (b·∫Øt ch√©o)</option>
    <option value="anova">So s√°nh nhi·ªÅu trung b√¨nh (ANOVA)</option>
    <option value="chisq">So s√°nh nhi·ªÅu t·ª∑ l·ªá (Chi-square)</option>
    <option value="survival">Ph√¢n t√≠ch s·ªëng c√≤n (Log-rank)</option>
    <option value="ancova">Repeated measures / ANCOVA</option>
  </select>

  <br><br>
  <div id="sample-size-form"></div>
  <div id="sample-size-formula" style="margin-top: 20px; font-style: italic;"></div>
  <div id="sample-size-reference" style="margin-top: 10px; color: gray; font-size: 0.9em;"></div>
  <button onclick="calculateSampleSize()">üßÆ T√≠nh c·ª° m·∫´u</button>
  <div id="sample-size-result" style="margin-top: 15px; font-weight: bold; color: green;"></div>
  <div id="sample-size-adjusted" style="margin-top: 5px; font-weight: bold; color: darkorange;"></div>
  <br><br>
  <h3>K·∫øt qu·∫£ t·ª´ GPT:</h3>
  <label>üìÇ T·∫£i t√†i li·ªáu PDF h·ªó tr·ª£ (n·∫øu c√≥):</label>
  <input type="file" id="file-sample-size" accept=".pdf"><br>
  <button onclick="generateSampleSizeSuggestion()">üß† GPT g·ª£i √Ω c√°ch t√≠nh</button>
  <div id="suggest-sample-size" style="white-space: pre-wrap; background: #eef; padding: 10px; border: 1px solid #99c;"></div>
  <button onclick="evaluateSampleSize()">üßê GPT ƒë√°nh gi√° c·ª° m·∫´u hi·ªán t·∫°i</button>
  <div id="eval-sample-size" style="white-space: pre-wrap; background: #efe; padding: 10px; border: 1px solid #9c9;"></div>
  <br>
  <button onclick="goToStep(5)">‚¨ÖÔ∏è Quay l·∫°i</button>
  <button onclick="goToStep(7)">Ti·∫øp ‚û°Ô∏è</button>
</div>

<!-- B∆∞·ªõc 8: Ti√™u ch√≠ ch·ªçn v√† lo·∫°i -->
<div class="step" id="step-7">
  <h2>B∆∞·ªõc 8: Ti√™u ch√≠ ch·ªçn v√† lo·∫°i</h2>

  <h3>Ti√™u ch√≠ ch·ªçn:</h3>
  <div id="inclusion-criteria"></div>
  <button onclick="addInclusionCriterion()">‚ûï Th√™m ti√™u ch√≠ ch·ªçn</button>

  <h3>Ti√™u ch√≠ lo·∫°i:</h3>
  <div id="exclusion-criteria"></div>
  <button onclick="addExclusionCriterion()">‚ûï Th√™m ti√™u ch√≠ lo·∫°i</button>
  <br><br>
  <h3>K·∫øt qu·∫£ t·ª´ GPT:</h3>
  <label>üìÇ T·∫£i t√†i li·ªáu PDF h·ªó tr·ª£ (n·∫øu c√≥):</label>
  <input type="file" id="file-criteria" accept=".pdf"><br>
  <button onclick="generateCriteriaFromGPT()">üß† GPT g·ª£i √Ω ti√™u ch√≠</button>
  <div id="criteria-gpt-suggestion" style="white-space: pre-wrap; background: #eef; padding: 10px; border: 1px solid #99c;"></div>
  <button onclick="evaluateCriteria()">üßê GPT ƒë√°nh gi√° ti√™u ch√≠ hi·ªán t·∫°i</button>
  <div id="criteria-gpt-evaluation" style="white-space: pre-wrap; background: #efe; padding: 10px; border: 1px solid #9c9;"></div>

  <br>
  <button onclick="goToStep(6)">‚¨ÖÔ∏è Quay l·∫°i</button>
  <button onclick="goToStep(8)">Ti·∫øp ‚û°Ô∏è</button>
</div>

<!-- B∆∞·ªõc 9: Ph√¢n b·ªï ng·∫´u nhi√™n -->
<div class="step" id="step-8">
  <h2>B∆∞·ªõc 9: Ph√¢n b·ªï ng·∫´u nhi√™n</h2>
  <label>S·ªë l∆∞·ª£ng nh√°nh can thi·ªáp (t·ª± ƒë·ªông l·∫•y t·ª´ b∆∞·ªõc 6):</label>
  <input type="number" id="num-arms-step9" readonly style="background-color:#f0f0f0;"><br><br>

  <label>Ch·ªçn ph∆∞∆°ng ph√°p ph√¢n b·ªï:</label>
  <select id="random-method" onchange="generateAutoRandomization(); saveData()">
    <option value="">-- Ch·ªçn ph∆∞∆°ng ph√°p --</option>
    <option value="simple">Ng·∫´u nhi√™n ƒë∆°n gi·∫£n</option>
    <option value="block">Ng·∫´u nhi√™n theo kh·ªëi</option>
    <option value="stratified">Ng·∫´u nhi√™n ph√¢n t·∫ßng</option>
    <option value="minimization">Ng·∫´u nhi√™n h√≥a t·ªëi thi·ªÉu</option>
  </select><br><br>
  <div id="random-options"></div>

  <label>M√¥ t·∫£ ng·∫´u nhi√™n h√≥a:</label>
  <textarea id="randomization-method" rows="5" oninput="saveData()"></textarea><br>
  
  <h3>K·∫øt qu·∫£ t·ª´ GPT:</h3>
  <label>üìÇ T·∫£i t√†i li·ªáu PDF h·ªó tr·ª£ (n·∫øu c√≥):</label>
  <input type="file" id="file-randomization" accept=".pdf"><br><br> 
  <button onclick="generateRandomizationSuggestion()">üß† GPT g·ª£i √Ω n·ªôi dung</button>
  <div id="randomization-gpt-suggestion" style="white-space: pre-wrap; background: #eef; padding: 10px; border: 1px solid #99c;"></div>
  <button onclick="evaluateRandomization()">‚úÖ GPT ƒë√°nh gi√° n·ªôi dung ƒë√£ nh·∫≠p</button>
  <div id="randomization-gpt-evaluation" style="white-space: pre-wrap; background: #efe; padding: 10px; border: 1px solid #9c9;"></div>
  <br><br>
  <button onclick="goToStep(7)">‚¨ÖÔ∏è Quay l·∫°i</button>
  <button onclick="goToStep(9)">Ti·∫øp ‚û°Ô∏è</button>
</div>

<!-- B∆∞·ªõc 10: M√¥ t·∫£ can thi·ªáp -->
<div class="step" id="step-9">
  <h2>B∆∞·ªõc 10: M√¥ t·∫£ Can thi·ªáp</h2>
  <div id="intervention-descriptions"></div>
  <br><br>
  <button onclick="goToStep(8)">‚¨ÖÔ∏è Quay l·∫°i</button>
  <button onclick="goToStep(10)">Ti·∫øp ‚û°Ô∏è</button>
</div>

<!-- B∆∞·ªõc 11: Bi·∫øn s·ªë nghi√™n c·ª©u -->
  <div class="step" id="step-10">
  <h2>B∆∞·ªõc 11: Bi·∫øn s·ªë nghi√™n c·ª©u</h2>
  <p>T·∫£i l√™n file CSV ch·ª©a danh s√°ch bi·∫øn m·∫´u ƒë√£ chu·∫©n h√≥a theo c√°c tr∆∞·ªùng c·∫ßn thi·∫øt. Sau ƒë√≥, k√©o-th·∫£ c√°c bi·∫øn v√†o t·ª´ng nh√≥m b√™n ph·∫£i ƒë·ªÉ ƒë∆∞a v√†o nghi√™n c·ª©u.</p>
  <input type="file" id="variable-file" accept=".csv">
  <hr>
  <h3>‚ûï Th√™m bi·∫øn m·ªõi:</h3>
  <div id="new-variable-form">
  <input type="text" placeholder="T√™n bi·∫øn" id="new-name">

  <select id="new-role" style="display:block; width:100%; margin-top:5px; margin-bottom:10px; padding:6px;">
    <option value="">-- Vai tr√≤ --</option>
    <option value="primary">K·∫øt c·ª•c ch√≠nh</option>
    <option value="secondary">K·∫øt c·ª•c ph·ª•</option>
    <option value="baseline">Bi·∫øn n·ªÅn</option>
    <option value="confounder">Bi·∫øn nhi·ªÖu</option>
    <option value="mediator">Bi·∫øn trung gian</option>
    <option value="moderator">Bi·∫øn ƒëi·ªÅu bi·∫øn</option>
    <option value="safety">Bi·∫øn an to√†n</option>
  </select>

  <select id="new-type" style="display:block; width:100%; margin-top:5px; margin-bottom:10px; padding:6px;">
    <option value="">-- Ki·ªÉu d·ªØ li·ªáu --</option>
    <option value="numeric">S·ªë li√™n t·ª•c (numeric)</option>
    <option value="ordinal">Th·ª© b·∫≠c (ordinal)</option>
    <option value="categorical">Ph√¢n lo·∫°i (categorical)</option>
    <option value="binary">Nh·ªã ph√¢n (binary: c√≥/kh√¥ng)</option>
    <option value="text">Chu·ªói vƒÉn b·∫£n (text)</option>
    <option value="date">Ng√†y th√°ng (date)</option>

  </select>

  <input type="text" placeholder="ƒê∆°n v·ªã" id="new-unit">
  <input type="text" placeholder="Th·ªùi ƒëi·ªÉm ƒëo" id="new-time">
  <input type="text" placeholder="C√°ch ƒëo l∆∞·ªùng" id="new-measure">
  <input type="text" placeholder="ƒê·ªãnh nghƒ©a" id="new-definition">
  <input type="text" placeholder="Ngu·ªìn" id="new-source">

  <select id="new-format" style="display:block; width:100%; margin-top:5px; margin-bottom:10px; padding:6px;">
    <option value="">-- ƒê·ªãnh d·∫°ng --</option>
    <option value="float">S·ªë th·ª±c (float)</option>
    <option value="integer">S·ªë nguy√™n (integer)</option>
    <option value="string">Chu·ªói k√Ω t·ª± (string)</option>
    <option value="percent">Ph·∫ßn trƒÉm (percent)</option>
    <option value="yes/no">C√≥ / Kh√¥ng (yes / no)</option>
    <option value="mm/dd/yyyy">Ng√†y (mm/dd/yyyy)</option>
  </select>

  <input type="text" placeholder="Kho·∫£ng gi√° tr·ªã" id="new-range">
  <input type="text" placeholder="MCID / Ng∆∞·ª°ng" id="new-mcid">
  <br>
  <button onclick="addNewVariable()">‚úÖ Th√™m v√†o danh s√°ch</button>
  <button onclick="exportVariables()">üíæ Xu·∫•t file CSV bi·∫øn ƒë√£ c·∫≠p nh·∫≠t</button>
</div>

  <div id="variable-groups"></div>
  <br><br>
  <button onclick="goToStep(9)">‚¨ÖÔ∏è Quay l·∫°i</button>
  <button onclick="goToStep(11)">Ti·∫øp ‚û°Ô∏è</button>
</div>

<script>
let allVariables = [];
let selectedVariables = {};
const variableRoles = [
  {
    key: "primary",
    name: "K·∫øt c·ª•c ch√≠nh",
    required: true,
    description: "Bi·∫øn s·ªë ch√≠nh ƒë·ªÉ ƒë√°nh gi√° hi·ªáu qu·∫£ can thi·ªáp. B·∫Øt bu·ªôc c√≥."
  },
  {
    key: "secondary",
    name: "K·∫øt c·ª•c ph·ª•",
    required: false,
    description: "Bi·∫øn s·ªë b·ªï sung ƒë·ªÉ ƒë√°nh gi√° c√°c kh√≠a c·∫°nh kh√°c c·ªßa can thi·ªáp. N√™n c√≥."
  },
  {
    key: "baseline",
    name: "Bi·∫øn n·ªÅn",
    required: true,
    description: "ƒê·∫∑c ƒëi·ªÉm ban ƒë·∫ßu c·ªßa ng∆∞·ªùi b·ªánh d√πng ƒë·ªÉ m√¥ t·∫£ v√† ph√¢n t√≠ch. B·∫Øt bu·ªôc c√≥."
  },
  {
    key: "confounder",
    name: "Bi·∫øn nhi·ªÖu",
    required: false,
    description: "Bi·∫øn c√≥ th·ªÉ ·∫£nh h∆∞·ªüng k·∫øt qu·∫£ n·∫øu kh√¥ng ki·ªÉm so√°t. N√™n c√≥."
  },
  {
    key: "mediator",
    name: "Bi·∫øn trung gian",
    required: false,
    description: "Bi·∫øn gi√∫p gi·∫£i th√≠ch c∆° ch·∫ø t√°c ƒë·ªông c·ªßa can thi·ªáp ƒë·∫øn k·∫øt qu·∫£."
  },
  {
    key: "moderator",
    name: "Bi·∫øn ƒëi·ªÅu bi·∫øn",
    required: false,
    description: "Bi·∫øn l√†m thay ƒë·ªïi m·ªëi li√™n h·ªá gi·ªØa can thi·ªáp v√† k·∫øt qu·∫£ (v√≠ d·ª•: t∆∞∆°ng t√°c)."
  },
  {
    key: "safety",
    name: "Bi·∫øn an to√†n",
    required: false,
    description: "Bi·∫øn ph·∫£n √°nh t√°c d·ª•ng ph·ª•, bi·∫øn c·ªë b·∫•t l·ª£i ho·∫∑c v·∫•n ƒë·ªÅ an to√†n trong nghi√™n c·ª©u."
  }
];

function createVariableDragUI() {
  const container = document.getElementById("variable-groups");
  container.innerHTML = "";

  variableRoles.forEach(role => {
    const availableList = (allVariables || []).filter(v => v.role === role.key);
    const selectedList = selectedVariables[role.key] || [];

    const block = document.createElement("div");
    block.className = "variable-group";

    // Ti√™u ƒë·ªÅ
    const heading = document.createElement("h4");
    heading.textContent = role.name;
    block.appendChild(heading);

    // M√¥ t·∫£
    const desc = document.createElement("div");
    desc.className = "description";
    desc.textContent = role.description;
    block.appendChild(desc);

    // Kh·ªëi 2 danh s√°ch
    const wrapper = document.createElement("div");
    wrapper.className = "variable-lists";

    // Danh s√°ch c√≥ th·ªÉ k√©o (ch∆∞a ch·ªçn)
    const availableUl = document.createElement("ul");
    availableUl.className = "variable-list variable-available";
    availableUl.dataset.role = role.key;
    availableUl.ondrop = drop;
    availableUl.ondragover = allowDrop;

    availableList.forEach(v => {
      const li = document.createElement("li");
      li.draggable = true;
      li.ondragstart = drag;
      li.dataset.name = v.name;
      li.dataset.role = v.role;
      li.textContent = `${v.name} (${v.type})`;
      const info = `
      T√™n: ${v.name}
      Vai tr√≤: ${v.role}
      Ki·ªÉu d·ªØ li·ªáu: ${v.type}
      ƒê∆°n v·ªã: ${v.unit}
      Th·ªùi ƒëi·ªÉm ƒëo: ${v.time}
      C√°ch ƒëo: ${v.measure}
      ƒê·ªãnh nghƒ©a: ${v.definition}
      Ngu·ªìn: ${v.source}
      ƒê·ªãnh d·∫°ng: ${v.format}
      Kho·∫£ng gi√° tr·ªã: ${v.range}
      MCID/Ng∆∞·ª°ng: ${v.mcid_or_cutoff}`.trim();
      li.title = info;        // üÜï g·∫Øn tooltip

      availableUl.appendChild(li);
    });

    // Danh s√°ch ƒë√£ ch·ªçn
    const selectedUl = document.createElement("ul");
    selectedUl.className = "variable-list variable-selected";
    selectedUl.dataset.role = role.key;
    selectedUl.ondrop = drop;
    selectedUl.ondragover = allowDrop;

    selectedList.forEach(v => {
      const li = document.createElement("li");
      li.draggable = true;
      li.ondragstart = drag;
      li.dataset.name = v.name;
      li.dataset.role = v.role;
      li.style.position = "relative";

      // T·∫°o th·∫ª span ch·ª©a n·ªôi dung vƒÉn b·∫£n
      const span = document.createElement("span");
      span.textContent = `${v.name} (${v.type})`;
      li.appendChild(span);

      const btn = document.createElement("button");
      btn.innerText = "üóë";
      btn.style.position = "absolute";
      btn.style.top = "4px";
      btn.style.right = "6px";
      btn.style.background = "none";
      btn.style.border = "none";
      btn.style.color = "red";
      btn.style.cursor = "pointer";
      btn.style.fontSize = "16px";
      btn.onclick = (e) => removeVariable(e, v.name, v.role);

      li.appendChild(btn);
      const info = `
      T√™n: ${v.name}
      Vai tr√≤: ${v.role}
      Ki·ªÉu d·ªØ li·ªáu: ${v.type}
      ƒê∆°n v·ªã: ${v.unit}
      Th·ªùi ƒëi·ªÉm ƒëo: ${v.time}
      C√°ch ƒëo: ${v.measure}
      ƒê·ªãnh nghƒ©a: ${v.definition}
      Ngu·ªìn: ${v.source}
      ƒê·ªãnh d·∫°ng: ${v.format}
      Kho·∫£ng gi√° tr·ªã: ${v.range}
      MCID/Ng∆∞·ª°ng: ${v.mcid_or_cutoff}`.trim();
      li.title = info;        // üÜï g·∫Øn tooltip
      selectedUl.appendChild(li);
    });

    wrapper.appendChild(availableUl);
    wrapper.appendChild(selectedUl);
    block.appendChild(wrapper);
    container.appendChild(block);

    // Khu v·ª±c GPT
    const pdfLabel = document.createElement("label");
    pdfLabel.innerText = "üìÇ T·∫£i t√†i li·ªáu PDF h·ªó tr·ª£:";
    block.appendChild(pdfLabel);

    const fileInput = document.createElement("input");
    fileInput.type = "file";
    fileInput.id = `file-variable-${role.key}`;
    fileInput.accept = ".pdf";
    block.appendChild(fileInput);

    block.appendChild(document.createElement("br"));

    // üëâ T·∫°o kh·ªëi ch·ª©a 2 n√∫t
const btnRow = document.createElement("div");
btnRow.style.display = "flex";
btnRow.style.flexDirection = "row";
btnRow.style.gap = "10px"; // kho·∫£ng c√°ch gi·ªØa 2 n√∫t
btnRow.style.marginTop = "8px";

// üëâ N√∫t GPT g·ª£i √Ω
const suggestBtn = document.createElement("button");
suggestBtn.innerText = "üß† GPT g·ª£i √Ω bi·∫øn";
suggestBtn.onclick = () => suggestVariablesForRole(role.key);
suggestBtn.style.display = "inline-flex";
suggestBtn.style.alignSelf = "flex-start";
suggestBtn.style.maxWidth = "fit-content";
suggestBtn.style.padding = "6px 12px";
suggestBtn.style.fontSize = "14px";
suggestBtn.style.border = "1px solid #bbb";
suggestBtn.style.borderRadius = "6px";
suggestBtn.style.backgroundColor = "#f0f0f0";
suggestBtn.style.color = "#333";
suggestBtn.style.cursor = "pointer";
suggestBtn.onmouseover = () => suggestBtn.style.backgroundColor = "#ddd";
suggestBtn.onmouseout = () => suggestBtn.style.backgroundColor = "#f0f0f0";
btnRow.appendChild(suggestBtn);

// üëâ N√∫t GPT ƒë√°nh gi√°
const evalBtn = document.createElement("button");
evalBtn.innerText = "üßê GPT ƒë√°nh gi√° bi·∫øn";
evalBtn.onclick = () => evaluateVariablesForRole(role.key);
evalBtn.style.display = "inline-flex";
evalBtn.style.alignSelf = "flex-start";
evalBtn.style.maxWidth = "fit-content";
evalBtn.style.padding = "6px 12px";
evalBtn.style.fontSize = "14px";
evalBtn.style.border = "1px solid #bbb";
evalBtn.style.borderRadius = "6px";
evalBtn.style.backgroundColor = "#f0f0f0";
evalBtn.style.color = "#333";
evalBtn.style.cursor = "pointer";
evalBtn.onmouseover = () => evalBtn.style.backgroundColor = "#ddd";
evalBtn.onmouseout = () => evalBtn.style.backgroundColor = "#f0f0f0";
btnRow.appendChild(evalBtn);

// üëâ Th√™m d√£y n√∫t v√†o block ch√≠nh
block.appendChild(btnRow);

// Khu v·ª±c hi·ªÉn th·ªã k·∫øt qu·∫£ GPT
const suggestDiv = document.createElement("div");
suggestDiv.id = `suggest-variable-${role.key}`;
suggestDiv.style.cssText = "margin-top:10px; background:#eef; padding:10px; border:1px solid #99c; white-space:pre-wrap;";
block.appendChild(suggestDiv);

const evalDiv = document.createElement("div");
evalDiv.id = `eval-variable-${role.key}`;
evalDiv.style.cssText = "margin-top:10px; background:#efe; padding:10px; border:1px solid #9c9; white-space:pre-wrap;";
block.appendChild(evalDiv);

    // Th√™m kh·ªëi n√†y v√†o container ch√≠nh
    container.appendChild(block);
  });
}

function allowDrop(e) {
  e.preventDefault();
}

function drag(e) {
  e.dataTransfer.setData("text/plain", e.target.outerHTML);
  e.dataTransfer.setData("fromList", e.target.parentElement.classList.contains("variable-selected") ? "selected" : "available");
  e.dataTransfer.setData("role", e.target.dataset.role);
  e.dataTransfer.setData("name", e.target.dataset.name);
  e.target.classList.add("dragging");
}

function drop(e) {
  e.preventDefault();

  const from = e.dataTransfer.getData("fromList");
  const role = e.dataTransfer.getData("role");
  const name = e.dataTransfer.getData("name");

  if (!from || !role || !name) return;

  const v = (Array.isArray(allVariables) ? allVariables.find(x => x.name === name && x.role === role) : null) || {};
  if (!v.name) return;

  const targetList = e.target.closest(".variable-list");
  if (!targetList) return;

  if ([...targetList.querySelectorAll("li")].some(el => el.dataset.name === name)) return;

  const li = document.createElement("li");
  li.dataset.name = v.name;
  li.dataset.role = v.role;
  li.dataset.type = v.type || "";
  li.dataset.unit = v.unit || "";
  li.dataset.time = v.time || "";
  li.dataset.measure = v.measure || "";
  li.dataset.definition = v.definition || "";
  li.dataset.source = v.source || "";
  li.dataset.format = v.format || "";
  li.dataset.range = v.range || "";
  li.dataset.mcid = v.mcid_or_cutoff || "";

  li.draggable = true;
  li.ondragstart = drag;
  li.style.position = "relative";

  const span = document.createElement("span");
  span.textContent = `${v.name} (${v.type || ""})`;
  li.appendChild(span);

  const info = (
    `T√™n: ${v.name}
Vai tr√≤: ${v.role}
Ki·ªÉu d·ªØ li·ªáu: ${v.type}
ƒê∆°n v·ªã: ${v.unit}
Th·ªùi ƒëi·ªÉm ƒëo: ${v.time}
C√°ch ƒëo: ${v.measure}
ƒê·ªãnh nghƒ©a: ${v.definition}
Ngu·ªìn: ${v.source}
ƒê·ªãnh d·∫°ng: ${v.format}
Kho·∫£ng gi√° tr·ªã: ${v.range}
MCID/Ng∆∞·ª°ng: ${v.mcid_or_cutoff}`
  ).trim();
  li.title = info;

  const btn = document.createElement("button");
  btn.innerText = "üóë";
  btn.style.position = "absolute";
  btn.style.top = "4px";
  btn.style.right = "6px";
  btn.style.background = "none";
  btn.style.border = "none";
  btn.style.color = "red";
  btn.style.cursor = "pointer";
  btn.style.fontSize = "16px";
  btn.onclick = (evt) => removeVariable(evt, v.name, v.role);
  li.appendChild(btn);

  targetList.appendChild(li);

  // N·∫øu k√©o t·ª´ available, x√≥a kh·ªèi danh s√°ch ngu·ªìn
  if (from === "available") {
    const fromList = document.querySelector(`.variable-available[data-role="${role}"]`);
    const itemToRemove = [...fromList.querySelectorAll("li")].find(el => el.dataset.name === name);
    if (itemToRemove) itemToRemove.remove();
  }

  // C·∫≠p nh·∫≠t selectedVariables
  selectedVariables[role] = [...targetList.querySelectorAll("li")].map(el => ({
    name: el.dataset.name,
    role: el.dataset.role,
    type: el.dataset.type || "",
    unit: el.dataset.unit || "",
    time: el.dataset.time || "",
    measure: el.dataset.measure || "",
    definition: el.dataset.definition || "",
    source: el.dataset.source || "",
    format: el.dataset.format || "",
    range: el.dataset.range || "",
    mcid_or_cutoff: el.dataset.mcid || ""
  }));
  saveData();
};

// ƒê·ªçc file CSV bi·∫øn m·∫´u
document.getElementById("variable-file").addEventListener("change", async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  const text = await file.text();
  const result = Papa.parse(text.trim(), { header: true, skipEmptyLines: true });

  allVariables = result.data.map(row => ({
    name: row.name?.trim() || "",
    role: row.role?.trim() || "",
    type: row.type?.trim() || "",
    unit: row.unit || "",
    time: row.time || "",
    measure: row.measure || "",
    definition: row.definition || "",
    source: row.source || "",
    format: row.format || "",
    range: row.range || "",
    mcid_or_cutoff: row.mcid_or_cutoff || ""
  }));
  console.log("‚úÖ Loaded variables:", allVariables);
  createVariableDragUI();
});

</script>

<!-- B∆∞·ªõc 12: M√¥ t·∫£ thu th·∫≠p d·ªØ li·ªáu -->
<div class="step" id="step-11">
  <h2>B∆∞·ªõc 12: M√¥ t·∫£ c√°ch thu th·∫≠p d·ªØ li·ªáu</h2>
  <label>üìù M√¥ t·∫£ c√°ch thu th·∫≠p d·ªØ li·ªáu:</label><br>
  <textarea id="collect-desc" rows="8" style="width:100%;" placeholder="V√≠ d·ª•: D·ªØ li·ªáu s·∫Ω ƒë∆∞·ª£c thu th·∫≠p t·∫°i 3 th·ªùi ƒëi·ªÉm..."></textarea>
  <div id="data-collection-list"></div>
  <br><br>
  <h3>K·∫øt qu·∫£ t·ª´ GPT:</h3>
  <label>üìÇ T·∫£i t√†i li·ªáu PDF h·ªó tr·ª£ (n·∫øu c√≥):</label>
  <input type="file" id="file-collect-pdf" accept=".pdf"><br><br>
  <button onclick="generateCollectSuggestion()">üß† GPT g·ª£i √Ω m√¥ t·∫£ thu th·∫≠p</button>
  <div id="suggest-collect" style="margin-top:10px; background:#eef; padding:10px; border:1px solid #99c; white-space:pre-wrap;"></div>
  <button onclick="evaluateCollectDescription()">üßê GPT ƒë√°nh gi√° m√¥ t·∫£ ƒë√£ nh·∫≠p</button>
  <div id="eval-collect" style="margin-top:10px; background:#efe; padding:10px; border:1px solid #9c9; white-space:pre-wrap;"></div>

  <br>
  <button onclick="goToStep(10)">‚¨ÖÔ∏è Quay l·∫°i</button>
  <button onclick="goToStep(12)">Ti·∫øp ‚û°Ô∏è</button>
</div>

<!-- B∆∞·ªõc 13: Ph√¢n t√≠ch s·ªë li·ªáu -->
<div class="step" id="step-12">
  <h2>B∆∞·ªõc 13: Ph√¢n t√≠ch s·ªë li·ªáu</h2>
  <label>üìù M√¥ t·∫£ chi·∫øn l∆∞·ª£c ph√¢n t√≠ch s·ªë li·ªáu:</label><br>
  <textarea id="analysis-desc" rows="10" style="width:100%;" placeholder="V√≠ d·ª•: D·ªØ li·ªáu s·∫Ω ƒë∆∞·ª£c ph√¢n t√≠ch theo nguy√™n t·∫Øc ITT..."></textarea>
  <div id="analysis-list"></div>
  <br><br>
  <h3>K·∫øt qu·∫£ t·ª´ GPT:</h3>
  <label>üìÇ T·∫£i t√†i li·ªáu PDF h·ªó tr·ª£ (n·∫øu c√≥):</label>
  <input type="file" id="file-analysis-pdf" accept=".pdf"><br><br>
  <button onclick="generateAnalysisPlan()">üß† GPT g·ª£i √Ω chi·∫øn l∆∞·ª£c ph√¢n t√≠ch</button>
  <div id="suggest-analysis" style="margin-top:10px; background:#eef; padding:10px; white-space:pre-wrap; border:1px solid #99c;"></div>
  <button onclick="evaluateAnalysisPlan()">üßê GPT ƒë√°nh gi√° n·ªôi dung ƒë√£ vi·∫øt</button>
  <div id="eval-analysis" style="margin-top:10px; background:#efe; padding:10px; white-space:pre-wrap; border:1px solid #9c9;"></div>
  <br>
  <button onclick="goToStep(11)">‚¨ÖÔ∏è Quay l·∫°i</button>
  <button onclick="goToStep(13)">Ti·∫øp ‚û°Ô∏è</button>
</div>

<!-- B∆∞·ªõc 14: ƒê·∫°o ƒë·ª©c nghi√™n c·ª©u -->
<div class="step" id="step-13">
  <h2>B∆∞·ªõc 14: ƒê·∫°o ƒë·ª©c nghi√™n c·ª©u</h2>
  <label>üìù M√¥ t·∫£ ph·∫ßn ƒë·∫°o ƒë·ª©c nghi√™n c·ª©u:</label><br>
  <textarea id="ethics-desc" rows="10" style="width:100%;" placeholder="V√≠ d·ª•: Nghi√™n c·ª©u tu√¢n th·ªß Tuy√™n b·ªë Helsinki..."></textarea><br><br>
  <h3>K·∫øt qu·∫£ t·ª´ GPT:</h3>
  <label>üìÇ T·∫£i t√†i li·ªáu PDF h·ªó tr·ª£ (n·∫øu c√≥):</label>
  <input type="file" id="file-ethics-pdf" accept=".pdf"><br><br>
  <button onclick="generateEthicsSection()">üß† GPT g·ª£i √Ω n·ªôi dung ƒë·∫°o ƒë·ª©c</button>
  <div id="suggest-ethics" style="margin-top:10px; background:#eef; padding:10px; white-space:pre-wrap; border:1px solid #99c;"></div>
  <button onclick="evaluateEthicsSection()">üßê GPT ƒë√°nh gi√° n·ªôi dung ƒë√£ vi·∫øt</button>
  <div id="eval-ethics" style="margin-top:10px; background:#efe; padding:10px; white-space:pre-wrap; border:1px solid #9c9;"></div>
  <br>
  <button onclick="goToStep(12)">‚¨ÖÔ∏è Quay l·∫°i</button>
  <button onclick="goToStep(14)">Ti·∫øp ‚û°Ô∏è</button>
</div>

<!-- B∆∞·ªõc 15: Ki·ªÉm tra logic t·ªïng th·ªÉ -->
<div class="step" id="step-14">
  <h2>B∆∞·ªõc 15: Ki·ªÉm tra logic t·ªïng th·ªÉ</h2>
  <p>üß† GPT s·∫Ω ki·ªÉm tra to√†n b·ªô ƒë·ªÅ c∆∞∆°ng b·∫°n ƒë√£ nh·∫≠p, g·ªìm PICO, m·ª•c ti√™u, bi·∫øn s·ªë, m√¥ t·∫£ can thi·ªáp, ph√¢n t√≠ch, ƒë·∫°o ƒë·ª©c‚Ä¶ ƒë·ªÉ ph√°t hi·ªán m√¢u thu·∫´n, thi·∫øu s√≥t ho·∫∑c g·ª£i √Ω c·∫£i ti·∫øn.</p>
  <button onclick="checkLogic()">üß† Ki·ªÉm tra logic to√†n b·ªô ƒë·ªÅ c∆∞∆°ng</button>
  <div id="logic-check-result" style="margin-top:15px; background:#ffe; padding:10px; white-space:pre-wrap; border:1px solid #cc0;"></div>
  <br>
  <button onclick="goToStep(13)">‚¨ÖÔ∏è Quay l·∫°i</button>
  <button onclick="goToStep(15)">Ti·∫øp ‚û°Ô∏è</button>
</div>

<!-- B∆∞·ªõc 16: S∆° ƒë·ªì ti·∫øn h√†nh nghi√™n c·ª©u -->
<div class="step" id="step-15">
  <h2>B∆∞·ªõc 16: S∆° ƒë·ªì ti·∫øn h√†nh nghi√™n c·ª©u</h2>
  <pre id="studyflow-mermaid" class="mermaid" style="padding: 20px; border: 1px solid #ccc;"></pre>
  <br>
  <button onclick="renderStudyFlowDiagram()">üîÅ V·∫Ω l·∫°i s∆° ƒë·ªì</button>
  <button onclick="downloadMermaidPNG()">üì∑ T·∫£i PNG</button>
  <br><br>
  <button onclick="goToStep(14)">‚¨ÖÔ∏è Quay l·∫°i</button>
  <button onclick="alert('üéâ ƒê√£ ho√†n t·∫•t to√†n b·ªô ƒë·ªÅ c∆∞∆°ng!')">K·∫øt th√∫c ‚úÖ</button>
</div>

<script>
// ====================== PH·∫¶N 1: H√†m cho c√°c b∆∞·ªõc ===========================

//Chung cho m·ªçi b∆∞·ªõc

async function extractTextFromPDF(file) {
  const arrayBuffer = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
  let fullText = '';

  for (let i = 1; i <= pdf.numPages; i++) {
    const page = await pdf.getPage(i);
    const content = await page.getTextContent();
    const strings = content.items.map(item => item.str);
    fullText += strings.join(' ') + '\n';
  }

  return fullText;
}

//B∆∞·ªõc 1

async function generatePicoDescription() {
  const p = document.getElementById("pico-p").value.trim();
  const i = document.getElementById("pico-i").value.trim();
  const c = document.getElementById("pico-c").value.trim();
  const o = document.getElementById("pico-o").value.trim();
  const fileInput = document.getElementById("pico-file");
  const files = Array.from(fileInput.files);

  if (!p || !i || !c || !o) {
    alert("Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin P, I, C, O tr∆∞·ªõc khi d√πng GPT.");
    return;
  }

  document.getElementById("pico-gpt-result").innerText = "ƒêang x·ª≠ l√Ω...";

  let fileText = "";
for (const file of files) {
  if (file.type === "application/pdf") {
    try {
      const text = await extractTextFromPDF(file);
      fileText += `--- N·ªôi dung t·ª´ file: ${file.name} ---\n${text}\n\n`;
    } catch (err) {
      console.error("L·ªói ƒë·ªçc file:", file.name, err);
    }
  }
}

  const prompt = fileText
    ? `T√†i li·ªáu sau ƒë√¢y ƒë∆∞·ª£c tr√≠ch t·ª´ b√†i b√°o ng∆∞·ªùi d√πng cung c·∫•p:\n\n${fileText}\n\n---\nD·ª±a tr√™n n·ªôi dung t√†i li·ªáu tr√™n v√† th√¥ng tin PICO sau, h√£y vi·∫øt m·ªôt ƒëo·∫°n m√¥ t·∫£ nghi√™n c·ª©u RCT ph√π h·ª£p:\n- P: ${p}\n- I: ${i}\n- C: ${c}\n- O: ${o}`
    : `T√¥i ƒëang x√¢y d·ª±ng m·ªôt ƒë·ªÅ c∆∞∆°ng nghi√™n c·ª©u RCT v·ªõi th√¥ng tin PICO sau:\n- P: ${p}\n- I: ${i}\n- C: ${c}\n- O: ${o}\nH√£y vi·∫øt m·ªôt ƒëo·∫°n m√¥ t·∫£ nghi√™n c·ª©u ng·∫Øn g·ªçn, r√µ r√†ng.`;

  try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();
  const data = JSON.parse(text);

  document.getElementById("pico-gpt-result").innerText =
    data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ n·ªôi dung.";
} catch (e) {
  document.getElementById("pico-gpt-result").innerText =
    "‚ùå L·ªói khi g·ªçi ho·∫∑c x·ª≠ l√Ω GPT: " + e.message;
}


//B∆∞·ªõc 2

async function generateResearchQuestionFromGPT() {
  const p = document.getElementById("pico-p").value.trim();
  const i = document.getElementById("pico-i").value.trim();
  const c = document.getElementById("pico-c").value.trim();
  const o = document.getElementById("pico-o").value.trim();
  const fileInput = document.getElementById("question-file");
  const files = Array.from(fileInput.files);

  if (!p || !i || !c || !o) {
    alert("C·∫ßn ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin PICO tr∆∞·ªõc khi GPT g·ª£i √Ω.");
    return;
  }

  document.getElementById("question-gpt-suggestion").innerText = "ƒêang g·ª£i √Ω t·ª´ GPT...";

  let fileText = "";
  for (const file of files) {
    if (file.type === "application/pdf") {
      try {
        const text = await extractTextFromPDF(file);
        fileText += `--- N·ªôi dung t·ª´ file: ${file.name} ---\n${text}\n\n`;
      } catch (err) {
        console.error("L·ªói khi ƒë·ªçc PDF:", err);
      }
    }
  }

  const prompt = `${fileText ? "D∆∞·ªõi ƒë√¢y l√† n·ªôi dung t·ª´ t√†i li·ªáu PDF:\n" + fileText : ""}
Th√¥ng tin PICO ƒë√£ c√≥:
- P: ${p}
- I: ${i}
- C: ${c}
- O: ${o}

D·ª±a v√†o t√†i li·ªáu v√† PICO tr√™n, h√£y vi·∫øt m·ªôt c√¢u h·ªèi nghi√™n c·ª©u RCT r√µ r√†ng, m·∫°ch l·∫°c, ph√π h·ª£p ƒë·ªÉ ƒë∆∞a v√†o ƒë·ªÅ c∆∞∆°ng.`

const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ prompt })
});

  const text = await response.text();
  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng ph·∫£n h·ªìi.";
    document.getElementById("question-gpt-suggestion").innerText = result;
  } catch (e) {
    document.getElementById("question-gpt-suggestion").innerText = "L·ªói khi ph√¢n t√≠ch ph·∫£n h·ªìi: " + text;
  }

async function evaluateResearchQuestion() {
  const question = document.getElementById("question").value.trim();
  const p = document.getElementById("pico-p").value.trim();
  const i = document.getElementById("pico-i").value.trim();
  const c = document.getElementById("pico-c").value.trim();
  const o = document.getElementById("pico-o").value.trim();

  if (!question) {
    alert("Vui l√≤ng nh·∫≠p c√¢u h·ªèi ƒë·ªÉ ƒë√°nh gi√°.");
    return;
  }

  document.getElementById("question-gpt-evaluation").innerText = "GPT ƒëang ƒë√°nh gi√°...";

  const prompt = `ƒê√¢y l√† m·ªôt c√¢u h·ªèi nghi√™n c·ª©u m√† ng∆∞·ªùi d√πng ƒë√£ vi·∫øt:\n"${question}"\n\n
1. H√£y ƒë√°nh gi√° c√¢u h·ªèi n√†y theo ti√™u ch√≠ **FINER** (Feasible, Interesting, Novel, Ethical, Relevant).
2. Ki·ªÉm tra xem n√≥ c√≥ ƒë·ªß y·∫øu t·ªë PICO kh√¥ng? N·∫øu thi·∫øu ph·∫ßn n√†o th√¨ ghi r√µ.
3. ƒê∆∞a ra nh·∫≠n x√©t v√† g·ª£i √Ω c·∫£i thi·ªán n·∫øu c·∫ßn.`;

const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ prompt })
});

  const text = await response.text();
  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng ph·∫£n h·ªìi.";
    document.getElementById("question-gpt-evaluation").innerText = result;
  } catch (e) {
    document.getElementById("question-gpt-evaluation").innerText = "L·ªói ph·∫£n h·ªìi: " + text;
  }

//B∆∞·ªõc 3 

function addSubObjective() {
  const container = document.createElement("div");
  container.style.display = "flex";
  container.style.gap = "10px";
  container.style.marginTop = "5px";

  const input = document.createElement("input");
  input.type = "text";
  input.className = "sub-objective";
  input.placeholder = "Nh·∫≠p m·ª•c ti√™u ph·ª•...";
  input.oninput = saveData;
  input.style.flex = "1";

  const btn = document.createElement("button");
  btn.innerText = "‚ùå";
  btn.title = "X√≥a m·ª•c ti√™u n√†y";
  btn.style.background = "none";
  btn.style.border = "1px solid #ccc";
  btn.style.padding = "4px 10px";
  btn.style.borderRadius = "6px";
  btn.style.cursor = "pointer";
  btn.style.color = "red";
  btn.onclick = () => {
    container.remove();
    saveData();
  };

  container.appendChild(input);
  container.appendChild(btn);

  document.getElementById("sub-objectives").appendChild(container);
  saveData();
}


async function generateObjectivesFromGPT() {
  const p = document.getElementById("pico-p").value.trim();
  const i = document.getElementById("pico-i").value.trim();
  const c = document.getElementById("pico-c").value.trim();
  const o = document.getElementById("pico-o").value.trim();
  const fileInput = document.getElementById("objective-file");
  const files = Array.from(fileInput.files);

  if (!p || !i || !c || !o) {
    alert("C·∫ßn nh·∫≠p ƒë·ªß PICO tr∆∞·ªõc khi GPT g·ª£i √Ω m·ª•c ti√™u.");
    return;
  }

  document.getElementById("objective-gpt-suggestion").innerText = "ƒêang g·ª£i √Ω t·ª´ GPT...";

  let fileText = "";
  for (const file of files) {
    if (file.type === "application/pdf") {
      try {
        const text = await extractTextFromPDF(file);
        fileText += `--- N·ªôi dung t·ª´ file: ${file.name} ---\n${text}\n\n`;
      } catch (err) {
        console.error("L·ªói ƒë·ªçc file PDF:", err);
      }
    }
  }

  const prompt = `${fileText ? "T√†i li·ªáu ng∆∞·ªùi d√πng cung c·∫•p:\n" + fileText : ""}
Th√¥ng tin t·ª´ b∆∞·ªõc PICO:
- P: ${p}
- I: ${i}
- C: ${c}
- O: ${o}

D·ª±a v√†o t√†i li·ªáu v√† PICO tr√™n, h√£y vi·∫øt m·ª•c ti√™u ch√≠nh v√† 2‚Äì4 m·ª•c ti√™u ph·ª• ph√π h·ª£p v·ªõi m·ªôt ƒë·ªÅ c∆∞∆°ng nghi√™n c·ª©u RCT. M·ª•c ti√™u ph·∫£i r√µ r√†ng, ƒëo l∆∞·ªùng ƒë∆∞·ª£c, ƒë·ªß th√†nh ph·∫ßn PICO. D·ª±a tr√™n ki·∫øn th·ª©c y khoa hi·ªán t·∫°i v·ªÅ v·∫•n ƒë·ªÅ m√† t√¥i ƒëang nghi√™n c·ª©u. N·∫øu c√≥ t·∫£i l√™n t√†i li·ªáu, th√¨ ph·∫£i tr√≠ch d·∫´n r√µ ·ªü cu·ªëi c√πng l√† th√¥ng tin g√¨ ƒë√£ l·∫•y t·ª´ t√†i li·ªáu n√†o`

const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ prompt })
});

  const text = await response.text();
  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ k·∫øt qu·∫£.";
    document.getElementById("objective-gpt-suggestion").innerText = result;
  } catch (e) {
    document.getElementById("objective-gpt-suggestion").innerText = "L·ªói ph·∫£n h·ªìi: " + text;
  }

async function evaluateObjectives() {
  const main = document.getElementById("main-objective").value.trim();
  const subs = Array.from(document.querySelectorAll(".sub-objective")).map(el => el.value.trim()).filter(v => v);

  if (!main) {
    alert("Vui l√≤ng nh·∫≠p m·ª•c ti√™u ch√≠nh.");
    return;
  }

  const allObjectives = `M·ª•c ti√™u ch√≠nh:\n- ${main}\n\nM·ª•c ti√™u ph·ª•:\n${subs.map(s => "- " + s).join("\n")}`;

  const prompt = `D∆∞·ªõi ƒë√¢y l√† c√°c m·ª•c ti√™u nghi√™n c·ª©u m√† ng∆∞·ªùi d√πng ƒë√£ vi·∫øt:

${allObjectives}

1. ƒê√°nh gi√° t·ª´ng m·ª•c ti√™u theo ti√™u ch√≠ **FINER** (Feasible, Interesting, Novel, Ethical, Relevant).
2. Ki·ªÉm tra xem t·ª´ng m·ª•c ti√™u c√≥ r√µ r√†ng v√† ph√π h·ª£p **SMART** (Specific, Measurable, Achievable, Realistic, Time-bound).
3. N·∫øu c√≥ m·ª•c ti√™u n√†o ch∆∞a ƒë√∫ng ho·∫∑c qu√° r·ªông/m∆° h·ªì, h√£y n√™u r√µ v√† ƒë·ªÅ xu·∫•t c√°ch vi·∫øt l·∫°i t·ªët h∆°n.
4. ƒê·ªëi v·ªõi m·ª•c ti√™u ch√≠nh, ki·ªÉm tra xem c√≥ r√µ r√†ng v·ªÅ PICO kh√¥ng.`

  document.getElementById("objective-gpt-evaluation").innerText = "GPT ƒëang ƒë√°nh gi√°...";

const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ prompt })
});

  const text = await response.text();
  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng ph·∫£n h·ªìi.";
    document.getElementById("objective-gpt-evaluation").innerText = result;
  } catch (e) {
    document.getElementById("objective-gpt-evaluation").innerText = "L·ªói ph·∫£n h·ªìi: " + text;
  }


//B∆∞·ªõc 4

async function generateGPT_Territory() {
  const output = document.getElementById("suggest-territory");
  const file = document.getElementById("file-territory").files[0];

  const p = document.getElementById("pico-p")?.value || "";
  const i = document.getElementById("pico-i")?.value || "";
  const c = document.getElementById("pico-c")?.value || "";
  const o = document.getElementById("pico-o")?.value || "";
  const question = document.getElementById("question")?.value || "";
  const mainObjective = document.getElementById("main-objective")?.value || "";

  if (!p || !i || !c || !o || !mainObjective) {
    alert("Vui l√≤ng nh·∫≠p ƒë·ªß th√¥ng tin PICO v√† m·ª•c ti√™u tr∆∞·ªõc khi GPT g·ª£i √Ω.");
    return;
  }

  output.textContent = "ƒêang sinh n·ªôi dung...";

  let fileText = "";
  if (file && file.type === "application/pdf") {
    try {
      fileText = await extractTextFromPDF(file);
    } catch (err) {
      console.error("L·ªói ƒë·ªçc PDF:", err);
    }
  }

  const prompt = `${fileText ? "T√†i li·ªáu PDF:\n" + fileText + "\n\n" : ""}
Th√¥ng tin ƒë·ªÅ c∆∞∆°ng:
- P: ${p}
- I: ${i}
- C: ${c}
- O: ${o}
- C√¢u h·ªèi: ${question}
- M·ª•c ti√™u ch√≠nh: ${mainObjective}

H√£y vi·∫øt ph·∫ßn m·ªü ƒë·∫ßu nghi√™n c·ª©u (Territory) theo m√¥ h√¨nh CaRS, th·ªÉ hi·ªán b·ªëi c·∫£nh, t·∫ßm quan tr·ªçng c·ªßa lƒ©nh v·ª±c ƒëang nghi√™n c·ª©u. N√™n c√≥ c√°c s·ªë li·ªáu d·ªãch t·ªÖ h·ªçc v√† ch·ªâ s·ªë v·ªÅ g√°nh n·∫∑ng b·ªánh t·∫≠t ƒë·ªÉ th·ªÉ hi·ªán r√µ v·∫•n ƒë·ªÅ nghi√™n c·ª©u l√† c·∫•p thi·∫øt. N·∫øu c√≥ t·∫£i t√†i li·ªáu l√™n th√¨ khi s·ª≠ d·ª•ng th√¥ng tin trong t√†i li·ªáu n√†o ph·∫£i ƒë√°nh s·ªë tr√≠ch d·∫´n v√† cu·ªëi c√πng ph·∫£i cho danh m·ª•c t√†i li·ªáu ƒë√£ tham kh·∫£o theo AMA 11.`;

const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ prompt })
});

  const text = await response.text();
  try {
    const data = JSON.parse(text);
    output.textContent = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ n·ªôi dung.";
  } catch (err) {
    output.textContent = "L·ªói ph·∫£n h·ªìi: " + text;
  }

async function evaluateGPT_Territory() {
  const input = document.getElementById("intro-territory").value.trim();
  const output = document.getElementById("eval-territory");
  const file = document.getElementById("file-territory").files[0];

  output.innerText = "‚è≥ ƒêang ƒë√°nh gi√° Territory...";

  let fileText = "";
  if (file && file.type === "application/pdf") {
    try {
      fileText = await extractTextFromPDF(file);
    } catch (err) {
      console.error("L·ªói ƒë·ªçc PDF:", err);
    }
  }

  const prompt = `
ƒê√¢y l√† ph·∫ßn Territory (b·ªëi c·∫£nh nghi√™n c·ª©u) trong m·ªôt ƒë·ªÅ c∆∞∆°ng nghi√™n c·ª©u:

"${input}"

${fileText ? "T√†i li·ªáu PDF li√™n quan:\n" + fileText : ""}

H√£y ƒë√°nh gi√° ƒëo·∫°n Territory tr√™n theo c√°c ti√™u ch√≠ sau:
- ƒê√£ n√™u r√µ lƒ©nh v·ª±c nghi√™n c·ª©u v√† b·ªëi c·∫£nh chung ch∆∞a?
- C√≥ s·ªë li·ªáu, b·∫±ng ch·ª©ng h·ªó tr·ª£ kh√¥ng?
- C√≥ d·∫´n d·∫Øt ng∆∞·ªùi ƒë·ªçc v√†o ch·ªß ƒë·ªÅ nghi√™n c·ª©u ch√≠nh kh√¥ng?
- C√≥ logic, m·∫°ch l·∫°c v√† ph√π h·ª£p v·ªõi m·ª•c ti√™u nghi√™n c·ª©u kh√¥ng?

Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát.
  `;

  try {
    const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ prompt })
    });

    const text = await response.text();
    const data = JSON.parse(text);
    output.innerText = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ n·ªôi dung.";
  } catch (error) {
    output.innerText = "‚ùå L·ªói x·ª≠ l√Ω ph·∫£n h·ªìi GPT: " + error.message;
  }

async function generateGPT_Niche() {
  const output = document.getElementById("suggest-niche");
  const file = document.getElementById("file-niche").files[0];

  const territory = document.getElementById("intro-territory")?.value || "";

  if (!territory.trim()) {
    alert("C·∫ßn nh·∫≠p ho·∫∑c sinh ph·∫ßn Territory tr∆∞·ªõc khi vi·∫øt Niche.");
    return;
  }

  output.textContent = "ƒêang sinh n·ªôi dung...";

  let fileText = "";
  if (file && file.type === "application/pdf") {
    try {
      fileText = await extractTextFromPDF(file);
    } catch (err) {
      console.error("L·ªói ƒë·ªçc PDF:", err);
    }
  }

  const prompt = `${fileText ? "T√†i li·ªáu PDF:\n" + fileText + "\n\n" : ""}
Ph·∫ßn Territory ƒë√£ vi·∫øt:
${territory}

D·ª±a tr√™n ph·∫ßn Territory v√† t√†i li·ªáu, h√£y vi·∫øt ph·∫ßn Niche n√™u r√µ kho·∫£ng tr·ªëng ki·∫øn th·ª©c trong lƒ©nh v·ª±c nghi√™n c·ª©u. N·∫øu lƒ©nh v·ª±c nghi√™n c·ª©u l√† v·ªÅ m·ªôt can thi·ªáp c·ªßa y h·ªçc c·ªï truy·ªÅn tr√™n m·ªôt b·ªánh l√Ω c·ªßa y h·ªçc hi·ªán ƒë·∫°i, th√¨ ph·∫ßn n√†y n√™n theo logic l√†: (1) Y h·ªçc hi·ªán ƒë·∫°i ƒëang c√≤n nh·ªØng th√°ch th·ª©c, h·∫°n ch·∫ø n√†o trong qu·∫£n l√Ω to√†n di·ªán b·ªánh l√Ω/t√¨nh tr·∫°ng ƒëang ƒë·ªãnh nghi√™n c·ª©u, (2) Can thi·ªáp y h·ªçc c·ªï truy·ªÅn d·ª± ƒë·ªãnh nghi√™n c·ª©u trong RCT n√†y ƒë√£ c√≥ nh·ªØng b·∫±ng ch·ª©ng n√†o tr∆∞·ªõc ƒë√¢y g·ª£i √Ω l√† c√≥ hi·ªáu qu·∫£ ch∆∞a, (3) n√≥i r√µ l√† c√°c b·∫±ng ch·ª©ng hi·ªán t·∫°i c√≤n y·∫øu ra sao ƒë·ªÉ khi·∫øn ph·∫£i c√≥ th√™m b·∫±ng ch·ª©ng m·∫°nh h∆°n. N·∫øu c√≥ t·∫£i t√†i li·ªáu l√™n th√¨ khi s·ª≠ d·ª•ng th√¥ng tin trong t√†i li·ªáu n√†o ph·∫£i ƒë√°nh s·ªë tr√≠ch d·∫´n v√† cu·ªëi c√πng ph·∫£i cho danh m·ª•c t√†i li·ªáu ƒë√£ tham kh·∫£o theo AMA 11`;

const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ prompt })
});

  const text = await response.text();
  try {
    const data = JSON.parse(text);
    output.textContent = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ n·ªôi dung.";
  } catch (err) {
    output.textContent = "L·ªói ph·∫£n h·ªìi: " + text;
  }

async function evaluateGPT_Niche() {
  const input = document.getElementById("intro-niche").value.trim();
  const output = document.getElementById("eval-niche");
  const file = document.getElementById("file-niche").files[0];

  output.innerText = "‚è≥ ƒêang ƒë√°nh gi√° Niche...";

  let fileText = "";
  if (file && file.type === "application/pdf") {
    try {
      fileText = await extractTextFromPDF(file);
    } catch (err) {
      console.error("L·ªói ƒë·ªçc PDF:", err);
    }
  }

  const prompt = `
ƒê√¢y l√† ph·∫ßn Niche (kho·∫£ng tr·ªëng ki·∫øn th·ª©c) trong m·ªôt ƒë·ªÅ c∆∞∆°ng nghi√™n c·ª©u:

"${input}"

${fileText ? "T√†i li·ªáu PDF li√™n quan:\n" + fileText : ""}

H√£y ƒë√°nh gi√° ƒëo·∫°n Niche tr√™n theo c√°c ti√™u ch√≠ sau:
- ƒê√£ x√°c ƒë·ªãnh r√µ v·∫•n ƒë·ªÅ ch∆∞a ƒë∆∞·ª£c gi·∫£i quy·∫øt kh√¥ng?
- C√≥ vi·ªán d·∫´n ho·∫∑c m√¥ t·∫£ kho·∫£ng tr·ªëng trong y vƒÉn kh√¥ng?
- C√≥ li√™n k·∫øt h·ª£p l√Ω v·ªõi ph·∫ßn Territory kh√¥ng?
- Di·ªÖn ƒë·∫°t c√≥ logic v√† ph√π h·ª£p v·ªõi ƒë·ªãnh h∆∞·ªõng nghi√™n c·ª©u kh√¥ng?

Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát.
  `;

try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();
  const data = JSON.parse(text);
  output.innerText = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ n·ªôi dung.";
} catch (error) {
  output.innerText = "‚ùå L·ªói x·ª≠ l√Ω ho·∫∑c ph·∫£n h·ªìi GPT: " + error.message;
}

async function generateGPT_Occupy() {
  const output = document.getElementById("suggest-occupy");
  const file = document.getElementById("file-occupy").files[0];

  const niche = document.getElementById("intro-niche")?.value || "";
  const objective = document.getElementById("main-objective")?.value || "";

  if (!niche.trim() || !objective.trim()) {
    alert("C·∫ßn c√≥ n·ªôi dung Niche v√† m·ª•c ti√™u ch√≠nh tr∆∞·ªõc khi vi·∫øt Occupy.");
    return;
  }

  output.textContent = "ƒêang sinh n·ªôi dung...";

  let fileText = "";
  if (file && file.type === "application/pdf") {
    try {
      fileText = await extractTextFromPDF(file);
    } catch (err) {
      console.error("L·ªói ƒë·ªçc PDF:", err);
    }
  }

  const prompt = `${fileText ? "T√†i li·ªáu PDF:\n" + fileText + "\n\n" : ""}
Ph·∫ßn Niche ƒë√£ vi·∫øt:
${niche}

M·ª•c ti√™u ch√≠nh c·ªßa nghi√™n c·ª©u:
${objective}

D·ª±a tr√™n kho·∫£ng tr·ªëng ƒë√£ n√™u, h√£y vi·∫øt ph·∫ßn Occupy tr√¨nh b√†y c√°ch nghi√™n c·ª©u n√†y s·∫Ω chi·∫øm lƒ©nh kho·∫£ng tr·ªëng, d√πng ph∆∞∆°ng ph√°p g√¨ v√† l√Ω do h·ª£p l√Ω. C·∫ßn l√†m r√µ nghi√™n c·ª©u n√†y s·∫Ω kh·∫Øc ph·ª•c c√°i Niche ƒë√£ n√™u b·∫±ng c√°ch n√†o (ph∆∞∆°ng ph√°p can thi·ªáp m·ªõi, b·ªô d·ªØ li·ªáu ch·∫•t l∆∞·ª£ng v√† s·ªë l∆∞·ª£ng cao h∆°n, hay ph∆∞∆°ng ph√°p ph√¢n t√≠ch k·∫øt qu·∫£ m·ªõi m·∫°nh h∆°n...). N·∫øu c√≥ t·∫£i t√†i li·ªáu l√™n th√¨ khi s·ª≠ d·ª•ng th√¥ng tin trong t√†i li·ªáu n√†o ph·∫£i ƒë√°nh s·ªë tr√≠ch d·∫´n v√† cu·ªëi c√πng ph·∫£i cho danh m·ª•c t√†i li·ªáu ƒë√£ tham kh·∫£o theo AMA 11.`;

const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ prompt })
});

  const text = await response.text();
  try {
    const data = JSON.parse(text);
    output.textContent = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ n·ªôi dung.";
  } catch (err) {
    output.textContent = "L·ªói ph·∫£n h·ªìi: " + text;
  }

async function evaluateGPT_Occupy() {
  const input = document.getElementById("intro-occupy").value.trim();
  const output = document.getElementById("eval-occupy");
  const file = document.getElementById("file-occupy").files[0];

  output.innerText = "‚è≥ ƒêang ƒë√°nh gi√° Occupy...";

  let fileText = "";
  if (file && file.type === "application/pdf") {
    try {
      fileText = await extractTextFromPDF(file);
    } catch (err) {
      console.error("L·ªói ƒë·ªçc PDF:", err);
    }
  }

  const prompt = `
ƒê√¢y l√† ph·∫ßn Occupy (c√°ch nghi√™n c·ª©u chi·∫øm lƒ©nh kho·∫£ng tr·ªëng) trong m·ªôt ƒë·ªÅ c∆∞∆°ng nghi√™n c·ª©u:

"${input}"

${fileText ? "T√†i li·ªáu PDF li√™n quan:\n" + fileText : ""}

H√£y ƒë√°nh gi√° ƒëo·∫°n Occupy tr√™n theo c√°c ti√™u ch√≠ sau:
- ƒê√£ n√™u r√µ c√°ch nghi√™n c·ª©u s·∫Ω gi·∫£i quy·∫øt kho·∫£ng tr·ªëng ch∆∞a?
- C√≥ logic li√™n k·∫øt v·ªõi ph·∫ßn Niche kh√¥ng?
- C√≥ l√†m r√µ ƒë∆∞·ª£c vai tr√≤ v√† s·ª± c·∫ßn thi·∫øt c·ªßa nghi√™n c·ª©u kh√¥ng?
- C√≥ n√™u ƒë∆∞·ª£c √Ω t∆∞·ªüng, ph∆∞∆°ng ph√°p ho·∫∑c h∆∞·ªõng gi·∫£i quy·∫øt c·ª• th·ªÉ kh√¥ng?

Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát.
  `;

try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();
  try {
    const data = JSON.parse(text);
    output.innerText = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ n·ªôi dung.";
  } catch (jsonError) {
    output.innerText = "‚ùå L·ªói ph√¢n t√≠ch JSON: " + text;
  }
} catch (fetchError) {
  output.innerText = "‚ùå L·ªói khi g·ªçi GPT: " + fetchError.message;
}


//B∆∞·ªõc 5

function addLiteratureSection(title = "", content = "") {
  const container = document.getElementById("literature-sections");
  const div = document.createElement("div");
  div.className = "literature-section";
  div.innerHTML = `
    <input type="text" class="literature-title" placeholder="Ti√™u ƒë·ªÅ m·ª•c t·ªïng quan" value="${title}" oninput="saveData()">
    <textarea class="literature-content" placeholder="N·ªôi dung t·ªïng quan...">${content}</textarea>
    <button onclick="this.parentElement.remove(); saveData()">üóë X√≥a m·ª•c n√†y</button>
    <hr>
  `;
  container.appendChild(div);
}

async function generateGPT_YHHD_Overview() {
  const p = document.getElementById("pico-p").value.trim();
  const i = document.getElementById("pico-i").value.trim();
  const c = document.getElementById("pico-c").value.trim();
  const o = document.getElementById("pico-o").value.trim();
  const question = document.getElementById("question").value.trim();
  const objective = document.getElementById("main-objective").value.trim();

  const fileInput = document.getElementById("file-yhhd-overview");
  const file = fileInput.files[0];
  let fileText = "";

  if (file && file.type === "application/pdf") {
    try {
      fileText = await extractTextFromPDF(file);
    } catch (err) {
      console.error("L·ªói ƒë·ªçc PDF:", err);
    }
  }

  const prompt = `D·ª±a tr√™n th√¥ng tin sau:
- P: ${p}
- I: ${i}
- C: ${c}
- O: ${o}
- C√¢u h·ªèi nghi√™n c·ª©u: ${question}
- M·ª•c ti√™u ch√≠nh: ${objective}
- T√†i li·ªáu tham kh·∫£o: ${fileText}

H√£y vi·∫øt ph·∫ßn t·ªïng quan v·ªÅ ƒë·∫°i c∆∞∆°ng y h·ªçc hi·ªán ƒë·∫°i li√™n quan ƒë·∫øn b·ªánh/t√¨nh tr·∫°ng ƒëang nghi√™n c·ª©u ch·ªâ t·∫≠p trung v√†o kh√°i ni·ªám, ƒë·ªãnh nghƒ©a, c·∫ßn ph·∫£i tr√¨nh b√†y r√µ r√†ng, c√≥ d·∫´n d·∫Øt h·ª£p l√Ω nh∆∞ trong ph·∫ßn t·ªïng quan t√†i li·ªáu c·ªßa m·ªôt ƒë·ªÅ c∆∞∆°ng RCT. N·∫øu c√≥ t·∫£i t√†i li·ªáu l√™n th√¨ khi s·ª≠ d·ª•ng th√¥ng tin trong t√†i li·ªáu n√†o ph·∫£i ƒë√°nh s·ªë tr√≠ch d·∫´n v√† cu·ªëi c√πng ph·∫£i cho danh m·ª•c t√†i li·ªáu ƒë√£ tham kh·∫£o theo AMA 11.`;

  const output = document.getElementById("suggest-yhhd-overview");
  output.textContent = "‚è≥ ƒêang sinh n·ªôi dung t·ª´ GPT...";

 try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ k·∫øt qu·∫£.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω ph·∫£n h·ªìi GPT: " + text;
  }
} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

async function evaluateGPT_YHHD_Overview() {
  const inputText = document.getElementById('text-yhhd-overview').value.trim();
  const output = document.getElementById('eval-yhhd-overview');

  const prompt = `ƒê√°nh gi√° ƒëo·∫°n vƒÉn sau v·ªÅ m·ª©c ƒë·ªô ph√π h·ª£p khi vi·∫øt ph·∫ßn *ƒê·∫°i c∆∞∆°ng Y h·ªçc hi·ªán ƒë·∫°i* trong t·ªïng quan t√†i li·ªáu c·ªßa m·ªôt ƒë·ªÅ c∆∞∆°ng RCT. Xem x√©t c√°c ti√™u ch√≠: ƒë·ªô r√µ r√†ng, m·ª©c ƒë·ªô t·ªïng qu√°t, s·ª± li√™n k·∫øt ƒë·∫øn v·∫•n ƒë·ªÅ nghi√™n c·ª©u v√† c·∫≠p nh·∫≠t t√†i li·ªáu.
---
${inputText}`;

  output.textContent = "‚è≥ ƒêang ƒë√°nh gi√° b·∫±ng GPT...";
  try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}
  
async function generateGPT_Epidemiology() {
  const fileInput = document.getElementById('file-epidemiology');
  const output = document.getElementById('suggest-epidemiology');
  const file = fileInput.files[0];
  let fileText = "";

  if (file && file.type === "application/pdf") {
    output.textContent = "üìÑ ƒêang ƒë·ªçc n·ªôi dung t·ª´ PDF...";
    fileText = await extractTextFromPDF(file);
  }

  const p = document.getElementById("pico-p").value.trim();
  const i = document.getElementById("pico-i").value.trim();
  const c = document.getElementById("pico-c").value.trim();
  const o = document.getElementById("pico-o").value.trim();

  const prompt = `Vi·∫øt ph·∫ßn t·ªïng quan d·ªãch t·ªÖ h·ªçc v√† g√°nh n·∫∑ng b·ªánh t·∫≠t c·ªßa b·ªánh ho·∫∑c t√¨nh tr·∫°ng nghi√™n c·ª©u, ph√π h·ª£p v·ªõi b·ªëi c·∫£nh ƒë·ªÅ c∆∞∆°ng RCT. L∆∞u √Ω c·∫ßn minh ch·ª©ng m·∫°nh m·∫Ω b·∫±ng c√°ch s·ªë li·ªáu ·∫•n t∆∞·ª£ng, c√≥ √Ω nghƒ©a cao t·ª´ c√°c nghi√™n c·ª©u ƒë√£ c√¥ng b·ªë ho·∫∑c t·ª´ t√†i li·ªáu ng∆∞·ªùi d√πng t·∫£i l√™n. N·∫øu c√≥ t·∫£i t√†i li·ªáu l√™n th√¨ khi s·ª≠ d·ª•ng th√¥ng tin trong t√†i li·ªáu n√†o ph·∫£i ƒë√°nh s·ªë tr√≠ch d·∫´n v√† cu·ªëi c√πng ph·∫£i cho danh m·ª•c t√†i li·ªáu ƒë√£ tham kh·∫£o theo AMA 11. 
Th√¥ng tin nghi√™n c·ª©u:
- P: ${p}
- I: ${i}
- C: ${c}
- O: ${o}

${fileText ? "\nT√†i li·ªáu PDF cung c·∫•p:\n" + fileText : ""}`;

  output.textContent = "‚è≥ ƒêang sinh n·ªôi dung t·ª´ GPT...";
  
try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

async function evaluateGPT_Epidemiology() {
  const inputText = document.getElementById('text-epidemiology').value.trim();
  const output = document.getElementById('eval-epidemiology');

  const prompt = `ƒê√°nh gi√° ƒëo·∫°n vƒÉn sau v·ªÅ m·ª©c ƒë·ªô ƒë·∫ßy ƒë·ªß v√† h·ª£p l√Ω khi tr√¨nh b√†y ph·∫ßn *D·ªãch t·ªÖ h·ªçc v√† g√°nh n·∫∑ng b·ªánh t·∫≠t* trong t·ªïng quan t√†i li·ªáu c·ªßa ƒë·ªÅ c∆∞∆°ng nghi√™n c·ª©u. C·∫ßn nh·∫≠n x√©t xem c√°c s·ªë li·ªáu ƒë√£ h·ª£p l√Ω, ·∫•n t∆∞·ª£ng, c√≥ tr√≠ch d·∫´n t√†i li·ªáu tham kh·∫£o r√µ r√†ng, l√†m s√°ng t·ªè ƒë∆∞·ª£c b·ªánh/t√¨nh tr·∫°ng ƒëang nghi√™n c·ª©u l√† v·∫•n ƒë·ªÅ c·∫•p thi·∫øt kh√¥ng:
---
${inputText}`;

  output.textContent = "‚è≥ ƒêang ƒë√°nh gi√° n·ªôi dung...";
  try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

async function generateGPT_Diagnosis() {
  const fileInput = document.getElementById('file-diagnosis');
  const output = document.getElementById('suggest-diagnosis');
  const file = fileInput.files[0];
  let fileText = "";

  if (file && file.type === "application/pdf") {
    output.textContent = "üìÑ ƒêang ƒë·ªçc n·ªôi dung t·ª´ PDF...";
    fileText = await extractTextFromPDF(file);
  }

  const p = document.getElementById("pico-p").value.trim();
  const i = document.getElementById("pico-i").value.trim();
  const c = document.getElementById("pico-c").value.trim();
  const o = document.getElementById("pico-o").value.trim();

  const prompt = `D·ª±a tr√™n c√°c th√¥ng tin sau, h√£y vi·∫øt ph·∫ßn t·ªïng quan v·ªÅ *ch·∫©n ƒëo√°n y h·ªçc hi·ªán ƒë·∫°i* li√™n quan ƒë·∫øn b·ªánh ho·∫∑c t√¨nh tr·∫°ng ƒëang nghi√™n c·ª©u, ph√π h·ª£p v·ªõi m·ªôt ƒë·ªÅ c∆∞∆°ng RCT. N·∫øu b·ªánh/t√¨nh tr·∫°ng c√≥ ti√™u chu·∫©n ch·∫©n ƒëo√°n r√µ r√†ng do hi·ªáp h·ªôi chuy√™n ng√†nh uy t√≠n ƒë·ªÅ xu·∫•t th√¨ n√™u r√µ ti√™u chu·∫©n, k√®m ƒë·ªô nh·∫°y ƒë·ªô ƒë·∫∑c hi·ªáu c·ªßa ti√™u chu·∫©n (n·∫øu c√≥). N·∫øu kh√¥ng c√≥ ti√™u chu·∫©n ch·∫©n ƒëo√°n r√µ r√†ng, th√¨ c·∫ßn ƒë√°nh gi√° xem ti√™u chu·∫©n n√†o th∆∞·ªùng ƒë∆∞·ª£c d√πng ƒë·ªÉ tuy·ªÉn ch·ªçn m·∫´u trong c√°c RCT l·ªõn li√™n quan ƒë·∫øn b·ªánh/t√¨nh tr·∫°ng n√†y. N·∫øu c√≥ t·∫£i t√†i li·ªáu l√™n th√¨ khi s·ª≠ d·ª•ng th√¥ng tin trong t√†i li·ªáu n√†o ph·∫£i ƒë√°nh s·ªë tr√≠ch d·∫´n v√† cu·ªëi c√πng ph·∫£i cho danh m·ª•c t√†i li·ªáu ƒë√£ tham kh·∫£o theo AMA 11:
- P: ${p}
- I: ${i}
- C: ${c}
- O: ${o}

${fileText ? "\nT√†i li·ªáu ng∆∞·ªùi d√πng cung c·∫•p:\n" + fileText : ""}`;

  output.textContent = "‚è≥ ƒêang sinh n·ªôi dung t·ª´ GPT...";

  try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

async function evaluateGPT_Diagnosis() {
  const inputText = document.getElementById('text-diagnosis').value.trim();
  const output = document.getElementById('eval-diagnosis');

  const prompt = `ƒê√°nh gi√° ƒëo·∫°n vƒÉn sau v·ªÅ ƒë·ªô ph√π h·ª£p, ƒë·∫ßy ƒë·ªß v√† t√≠nh h·ªá th·ªëng khi tr√¨nh b√†y ph·∫ßn *ch·∫©n ƒëo√°n y h·ªçc hi·ªán ƒë·∫°i* trong ƒë·ªÅ c∆∞∆°ng nghi√™n c·ª©u RCT theo c√°c ti√™u ch√≠ l√† chi ti·∫øt, r√µ r√†ng, x√∫c t√≠ch, c√≥ minh ch·ª©ng ƒë·∫ßy ƒë·ªß, c√≥ ƒë∆∞·ª£c c·ªông ƒë·ªìng y khoa hi·ªán h√†nh c√¥ng nh·∫≠n kh√¥ng:
---
${inputText}`;

  output.textContent = "‚è≥ ƒêang ƒë√°nh gi√° n·ªôi dung...";

  try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}


async function generateGPT_Treatment() {
  const fileInput = document.getElementById('file-treatment');
  const output = document.getElementById('suggest-treatment');
  const file = fileInput.files[0];
  let fileText = "";

  if (file && file.type === "application/pdf") {
    output.textContent = "üìÑ ƒêang ƒë·ªçc n·ªôi dung t·ª´ PDF...";
    fileText = await extractTextFromPDF(file);
  }

  const p = document.getElementById("pico-p").value.trim();
  const i = document.getElementById("pico-i").value.trim();
  const c = document.getElementById("pico-c").value.trim();
  const o = document.getElementById("pico-o").value.trim();

  const prompt = `D·ª±a tr√™n th√¥ng tin sau, h√£y vi·∫øt ph·∫ßn t·ªïng quan v·ªÅ *ƒëi·ªÅu tr·ªã y h·ªçc hi·ªán ƒë·∫°i* cho t√¨nh tr·∫°ng ƒëang nghi√™n c·ª©u. N·∫øu c√≥ guideline h∆∞·ªõng d·∫´n c·ªßa hi·ªáp h·ªôi chuy√™n ng√†nh uy t√≠n th√¨ n√™n theo guideline ƒë√≥. C·∫ßn ch√∫ √Ω ƒë·∫øn t√≠nh k·∫øt h·ª£p li√™n ng√†nh v√† qu·∫£n l√Ω to√†n di·ªán. N·∫øu c√≥ t·∫£i t√†i li·ªáu l√™n th√¨ khi s·ª≠ d·ª•ng th√¥ng tin trong t√†i li·ªáu n√†o ph·∫£i ƒë√°nh s·ªë tr√≠ch d·∫´n v√† cu·ªëi c√πng ph·∫£i cho danh m·ª•c t√†i li·ªáu ƒë√£ tham kh·∫£o theo AMA 11:
- P: ${p}
- I: ${i}
- C: ${c}
- O: ${o}

${fileText ? "\nT√†i li·ªáu ng∆∞·ªùi d√πng cung c·∫•p:\n" + fileText : ""}`;

  output.textContent = "‚è≥ ƒêang sinh n·ªôi dung t·ª´ GPT...";

  try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

async function evaluateGPT_Treatment() {
  const inputText = document.getElementById('text-treatment').value.trim();
  const output = document.getElementById('eval-treatment');

  const prompt = `ƒê√°nh gi√° ƒëo·∫°n vƒÉn sau v·ªÅ t√≠nh ƒë·∫ßy ƒë·ªß, ch√≠nh x√°c v√† c·∫≠p nh·∫≠t trong ph·∫ßn *ƒëi·ªÅu tr·ªã y h·ªçc hi·ªán ƒë·∫°i* c·ªßa m·ªôt ƒë·ªÅ c∆∞∆°ng RCT. Xem x√©t c√°c kh√≠a c·∫°nh: ph√°c ƒë·ªì ƒëi·ªÅu tr·ªã ch√≠nh, b·∫±ng ch·ª©ng hi·ªáu qu·∫£, t√≠nh th·ª±c h√†nh v√† li√™n quan ƒë·∫øn PICO.
---
${inputText}`;

  output.textContent = "‚è≥ ƒêang ƒë√°nh gi√° n·ªôi dung...";

  try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

async function generateGPT_Limitation() {
  const fileInput = document.getElementById('file-limitation');
  const output = document.getElementById('suggest-limitation');
  const file = fileInput.files[0];
  let fileText = "";

  if (file && file.type === "application/pdf") {
    output.textContent = "üìÑ ƒêang ƒë·ªçc n·ªôi dung t·ª´ PDF...";
    fileText = await extractTextFromPDF(file);
  }

  const p = document.getElementById("pico-p").value.trim();
  const i = document.getElementById("pico-i").value.trim();
  const c = document.getElementById("pico-c").value.trim();
  const o = document.getElementById("pico-o").value.trim();

  const prompt = `D·ª±a tr√™n th√¥ng tin sau, h√£y vi·∫øt ph·∫ßn t·ªïng quan v·ªÅ *c√°c h·∫°n ch·∫ø c·ªßa Y h·ªçc hi·ªán ƒë·∫°i trong qu·∫£n l√Ω t√¨nh tr·∫°ng b·ªánh nghi√™n c·ª©u*. C·∫ßn c√≥ c√°c s·ªë li·ªáu th·ª±c t·∫ø t·ª´ c√°c RCT hay meta-analysis kh√°c ƒë·ªÉ ch·ª©ng minh c√°c li·ªáu ph√°p ƒëi·ªÅu tr·ªã hi·ªán t·∫°i c·ªßa y h·ªçc hi·ªán ƒë·∫°i v·ªÅ b·ªánh/t√¨nh tr·∫°ng trong nghi√™n c·ª©u n√†y c√≤n h·∫°n ch·∫ø ·ªü c√°c kh√≠a c·∫°nh nh∆∞ t·ª∑ l·ªá ƒë·∫°t hi·ªÉu qu·∫£ ch∆∞a qu√° cao, c√≤n nhi·ªÅu b·ªánh nh√¢n kh√°ng tr·ªã ho·∫∑c ƒë√°p ·ª©ng ƒëi·ªÅu tr·ªã kh√¥ng ƒë·∫ßy ƒë·ªß, k√©m tu√¢n th·ªß do t√°c d·ª•ng ph·ª•, c√≥ qu√° nhi·ªÅu bi·∫øn ch·ª©ng c·ªßa ƒëi·ªÅu tr·ªã, ho·∫∑c chi ph√≠ ƒëi·ªÅu tr·ªã qu√° cao. N·∫øu c√≥ t·∫£i t√†i li·ªáu l√™n th√¨ khi s·ª≠ d·ª•ng th√¥ng tin trong t√†i li·ªáu n√†o ph·∫£i ƒë√°nh s·ªë tr√≠ch d·∫´n v√† cu·ªëi c√πng ph·∫£i cho danh m·ª•c t√†i li·ªáu ƒë√£ tham kh·∫£o theo AMA 11:
- P: ${p}
- I: ${i}
- C: ${c}
- O: ${o}

${fileText ? "\nT√†i li·ªáu ng∆∞·ªùi d√πng cung c·∫•p:\n" + fileText : ""}`;

  output.textContent = "‚è≥ ƒêang sinh n·ªôi dung t·ª´ GPT...";

 try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

async function evaluateGPT_Limitation() {
  const inputText = document.getElementById('text-limitation').value.trim();
  const output = document.getElementById('eval-limitation');

  const prompt = `ƒê√°nh gi√° ƒëo·∫°n vƒÉn sau v·ªÅ t√≠nh h·ª£p l√Ω, c·ª• th·ªÉ v√† c·∫≠p nh·∫≠t khi tr√¨nh b√†y *c√°c h·∫°n ch·∫ø c·ªßa Y h·ªçc hi·ªán ƒë·∫°i* trong qu·∫£n l√Ω t√¨nh tr·∫°ng b·ªánh nghi√™n c·ª©u. Xem x√©t c√°c ti√™u ch√≠: ƒë·ªô ƒë·∫ßy ƒë·ªß, d·∫´n ch·ª©ng, v√† m·ª©c ƒë·ªô li√™n k·∫øt v·ªõi PICO.
---
${inputText}`;

  output.textContent = "‚è≥ ƒêang ƒë√°nh gi√° n·ªôi dung...";

 try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

async function generateGPT_YHCT_Overview() {
  const fileInput = document.getElementById('file-yhct-overview');
  const output = document.getElementById('suggest-yhct-overview');
  const file = fileInput.files[0];
  let fileText = "";

  if (file && file.type === "application/pdf") {
    output.textContent = "üìÑ ƒêang ƒë·ªçc n·ªôi dung t·ª´ PDF...";
    fileText = await extractTextFromPDF(file);
  }

  const p = document.getElementById("pico-p").value.trim();
  const i = document.getElementById("pico-i").value.trim();
  const c = document.getElementById("pico-c").value.trim();
  const o = document.getElementById("pico-o").value.trim();

  const prompt = `D·ª±a tr√™n th√¥ng tin sau, h√£y vi·∫øt ph·∫ßn *t·ªïng quan v·ªÅ Y h·ªçc c·ªï truy·ªÅn (YHCT)* li√™n quan ƒë·∫øn t√¨nh tr·∫°ng b·ªánh trong nghi√™n c·ª©u. T·∫≠p trung v√†o c√°c th√¥ng tin ch√≠nh nh∆∞ quan ni·ªám c·ªßa y h·ªçc c·ªï truy·ªÅn v·ªÅ b·ªánh/t√¨nh tr·∫°ng ƒëang nghi√™n c·ª©u ƒë∆∞·ª£c m√¥ t·∫£ trong ch·ª©ng n√†o c·ªßa y h·ªçc c·ªï truy·ªÅn, ch·ª©ng ƒë√≥ ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a l√† g√¨. C√°c c·ªï vƒÉn nh∆∞ T·ªë v·∫•n. Linh khu, Kim qu·ªπ y·∫øu l∆∞·ª£c, Th∆∞∆°ng h√†n lu·∫≠n, Ch∆∞ b·ªánh nguy√™n h·∫≠u lu·∫≠n, C·∫£nh Nh·∫°c to√†n th∆∞, ƒêan Kh√™ t√¢m ph√°p...ƒë√£ b√†n lu·∫≠n v·ªÅ ch·ª©ng n√†y ra sao (n·∫øu c√≥). N·∫øu c√≥ t·∫£i t√†i li·ªáu l√™n th√¨ khi s·ª≠ d·ª•ng th√¥ng tin trong t√†i li·ªáu n√†o ph·∫£i ƒë√°nh s·ªë tr√≠ch d·∫´n v√† cu·ªëi c√πng ph·∫£i cho danh m·ª•c t√†i li·ªáu ƒë√£ tham kh·∫£o theo AMA 11:
- P: ${p}
- I: ${i}
- C: ${c}
- O: ${o}

${fileText ? "\nT√†i li·ªáu ng∆∞·ªùi d√πng cung c·∫•p:\n" + fileText : ""}`;

  output.textContent = "‚è≥ ƒêang sinh n·ªôi dung t·ª´ GPT...";

 try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

async function evaluateGPT_YHCT_Overview() {
  const inputText = document.getElementById('text-yhct-overview').value.trim();
  const output = document.getElementById('eval-yhct-overview');

  const prompt = `ƒê√°nh gi√° ƒëo·∫°n vƒÉn sau v·ªÅ t√≠nh h·ª£p l√Ω, ƒë√∫ng l√Ω lu·∫≠n v√† ƒë·∫ßy ƒë·ªß khi tr√¨nh b√†y ph·∫ßn t·ªïng quan Y h·ªçc c·ªï truy·ªÅn (YHCT) v·ªÅ t√¨nh tr·∫°ng b·ªánh nghi√™n c·ª©u. C√°c ti√™u ch√≠ c·∫ßn c√¢n nh·∫Øc: C√≥ tr√≠ch d·∫´n r√µ r√†ng kh√¥ng? c√≥ nh·∫Øc ƒë·∫øn c·ªï vƒÉn kh√¥ng? c√≥ n√™u r√µ ƒë∆∞·ª£c b·ªánh/t√¨nh tr·∫°ng n√†y ƒë·ªëi v·ªõi y h·ªçc c·ªï truy·ªÅn th√¨ li√™n quan ƒë·∫øn ch·ª©ng tr·∫°ng n√†o kh√¥ng? N√™u r√µ ƒëi·ªÉm m·∫°nh, ƒëi·ªÉm y·∫øu n·∫øu c√≥:
---
${inputText}`;

  output.textContent = "‚è≥ ƒêang ƒë√°nh gi√° n·ªôi dung...";

  try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

async function generateGPT_Intervention() {
  const fileInput = document.getElementById('file-intervention');
  const output = document.getElementById('suggest-intervention');
  const file = fileInput.files[0];
  let fileText = "";

  if (file && file.type === "application/pdf") {
    output.textContent = "üìÑ ƒêang ƒë·ªçc n·ªôi dung t·ª´ PDF...";
    fileText = await extractTextFromPDF(file);
  }

  const p = document.getElementById("pico-p").value.trim();
  const i = document.getElementById("pico-i").value.trim();
  const c = document.getElementById("pico-c").value.trim();
  const o = document.getElementById("pico-o").value.trim();

  const prompt = `D·ª±a tr√™n th√¥ng tin sau, h√£y m√¥ t·∫£ chi ti·∫øt c√°c *li·ªáu ph√°p can thi·ªáp* c·ªßa y h·ªçc c·ªï truy·ªÅn ƒëang ƒë∆∞·ª£c nghi√™n c·ª©u. C·∫ßn ƒëi·ªÉm qua h·∫ßu h·∫øt c√°c li·ªáu ph√°p th∆∞·ªùng d√πng trong y h·ªçc c·ªï truy·ªÅn nh∆∞ ch√¢m c·ª©u, xoa b√≥p b·∫•m huy·ªát, c√°c h√¨nh th·ª©c t·∫≠p luy·ªán truy·ªÅn th·ªëng (kh√≠ c√¥ng, yoga, th√°i c·ª±c quy·ªÅn...), thu·ªëc thang, thu·ªëc th√†nh ph·∫©m, thu·ªëc x√¥ng, thu·ªëc d√°n...T·∫•t c·∫£ ƒë·ªÅu c·∫ßn c√≥ minh ch·ª©ng r√µ r√†ng b·∫±ng c√°c RCT ho·∫∑c c√°c meta-analysis ho·∫∑c c√°c guideline v·ªÅ y h·ªçc c·ªï truy·ªÅn. N·∫øu c√≥ t·∫£i t√†i li·ªáu l√™n th√¨ khi s·ª≠ d·ª•ng th√¥ng tin trong t√†i li·ªáu n√†o ph·∫£i ƒë√°nh s·ªë tr√≠ch d·∫´n v√† cu·ªëi c√πng ph·∫£i cho danh m·ª•c t√†i li·ªáu ƒë√£ tham kh·∫£o theo AMA 11:
- P: ${p}
- I: ${i}
- C: ${c}
- O: ${o}

${fileText ? "\nT√†i li·ªáu ng∆∞·ªùi d√πng cung c·∫•p:\n" + fileText : ""}`;

  output.textContent = "‚è≥ ƒêang sinh n·ªôi dung t·ª´ GPT...";

  try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

async function evaluateGPT_Intervention() {
  const inputText = document.getElementById('text-intervention').value.trim();
  const output = document.getElementById('eval-intervention');

  const prompt = `ƒê√°nh gi√° ƒëo·∫°n vƒÉn sau v·ªÅ *t√≠nh ƒë·∫ßy ƒë·ªß, r√µ r√†ng v√† khoa h·ªçc* trong m√¥ t·∫£ c√°c li·ªáu ph√°p can thi·ªáp (bao g·ªìm t√™n can thi·ªáp, li·ªÅu l∆∞·ª£ng, th·ªùi gian, ƒë∆∞·ªùng d√πng... n·∫øu c√≥). C√≥ ƒëi·ªÉm qua h·∫ßu h·∫øt c√°c li·ªáu ph√°p th∆∞·ªùng d√πng trong y h·ªçc c·ªï truy·ªÅn nh∆∞ ch√¢m c·ª©u, xoa b√≥p b·∫•m huy·ªát, c√°c h√¨nh th·ª©c t·∫≠p luy·ªán truy·ªÅn th·ªëng (kh√≠ c√¥ng, yoga, th√°i c·ª±c quy·ªÅn...), thu·ªëc thang, thu·ªëc th√†nh ph·∫©m, thu·ªëc x√¥ng, thu·ªëc d√°n hay ch∆∞a?. T·∫•t c·∫£ ƒë√£ c√≥ minh ch·ª©ng r√µ r√†ng b·∫±ng c√°c RCT ho·∫∑c c√°c meta-analysis ho·∫∑c c√°c guideline v·ªÅ y h·ªçc c·ªï truy·ªÅn ch∆∞a?:
---
${inputText}`;

  output.textContent = "‚è≥ ƒêang ƒë√°nh gi√° n·ªôi dung...";

  try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

async function generateGPT_RelatedStudies() {
  const fileInput = document.getElementById('file-related-studies');
  const output = document.getElementById('suggest-related-studies');
  const file = fileInput.files[0];
  let fileText = "";

  if (file && file.type === "application/pdf") {
    output.textContent = "üìÑ ƒêang ƒë·ªçc n·ªôi dung t·ª´ PDF...";
    fileText = await extractTextFromPDF(file);
  }

  const p = document.getElementById("pico-p").value.trim();
  const i = document.getElementById("pico-i").value.trim();
  const c = document.getElementById("pico-c").value.trim();
  const o = document.getElementById("pico-o").value.trim();

  const prompt = `D·ª±a tr√™n th√¥ng tin sau, h√£y vi·∫øt ph·∫ßn t·ªïng quan c√°c *nghi√™n c·ª©u li√™n quan trong v√† ngo√†i n∆∞·ªõc* ƒë·∫øn ch·ªß ƒë·ªÅ nghi√™n c·ª©u hi·ªán t·∫°i. M√¥ t·∫£ ng·∫Øn g·ªçn t·ª´ng nghi√™n c·ª©u, ch·ªâ ra ∆∞u ƒëi·ªÉm, h·∫°n ch·∫ø v√† s·ª± kh√°c bi·ªát so v·ªõi nghi√™n c·ª©u hi·ªán t·∫°i. N·∫øu c√≥ t·∫£i t√†i li·ªáu l√™n th√¨ khi s·ª≠ d·ª•ng th√¥ng tin trong t√†i li·ªáu n√†o ph·∫£i ƒë√°nh s·ªë tr√≠ch d·∫´n v√† cu·ªëi c√πng ph·∫£i cho danh m·ª•c t√†i li·ªáu ƒë√£ tham kh·∫£o theo AMA 11:
- P: ${p}
- I: ${i}
- C: ${c}
- O: ${o}

${fileText ? "\nT√†i li·ªáu ng∆∞·ªùi d√πng cung c·∫•p:\n" + fileText : ""}`;

  output.textContent = "‚è≥ ƒêang sinh n·ªôi dung t·ª´ GPT...";

  try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

async function evaluateGPT_RelatedStudies() {
  const inputText = document.getElementById('text-related-studies').value.trim();
  const output = document.getElementById('eval-related-studies');

  const prompt = `ƒê√°nh gi√° ƒëo·∫°n vƒÉn sau v·ªÅ *t√≠nh c·∫≠p nh·∫≠t, s·ª± li√™n quan v√† ph√¢n t√≠ch h·ª£p l√Ω* khi tr√¨nh b√†y c√°c nghi√™n c·ª©u li√™n quan trong v√† ngo√†i n∆∞·ªõc, l∆∞u √Ω l√† c·∫ßn ƒë√°nh gi√° xem li·ªáu ƒë√£ n√™u b·∫≠t ƒë∆∞·ª£c nh·ªØng h·∫°n ch·∫ø c·ªßa c√°c nghi√™n c·ª©u tr∆∞·ªõc ƒë√¢y m√† c√≥ th·ªÉ kh·∫Øc ph·ª•c ƒë∆∞·ª£c trong nghi√™n c·ª©u n√†y ch∆∞a:
---
${inputText}`;

  output.textContent = "‚è≥ ƒêang ƒë√°nh gi√° n·ªôi dung...";

 try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

async function generateGPT_NewMethods() {
  const fileInput = document.getElementById('file-new-methods');
  const output = document.getElementById('suggest-new-methods');
  const file = fileInput.files[0];
  let fileText = "";

  if (file && file.type === "application/pdf") {
    output.textContent = "üìÑ ƒêang tr√≠ch xu·∫•t n·ªôi dung t·ª´ PDF...";
    fileText = await extractTextFromPDF(file);
  }

  const p = document.getElementById("pico-p").value.trim();
  const i = document.getElementById("pico-i").value.trim();
  const c = document.getElementById("pico-c").value.trim();
  const o = document.getElementById("pico-o").value.trim();

  const prompt = `D·ª±a v√†o th√¥ng tin sau, h√£y vi·∫øt ph·∫ßn m√¥ t·∫£ c√°c *ph∆∞∆°ng ph√°p ph√¢n t√≠ch s·ªë li·ªáu m·ªõi ho·∫∑c c√°ch ƒë√°nh gi√° k·∫øt c·ª•c m·ªõi ho·∫∑c c√¥ng c·ª• ƒëo l∆∞·ªùng m·ªõi* c√≥ th·ªÉ √°p d·ª•ng cho nghi√™n c·ª©u n√†y. Gi·∫£i th√≠ch t·∫°i sao n√™n d√πng, v√† l·ª£i √≠ch so v·ªõi c√°ch c≈©. C·∫ßn c√≥ tr√≠ch d·∫´n t√†i li·ªáu tham kh·∫£o v√† ƒë√°nh s·ªë t√†i li·ªáu tham kh·∫£o r√µ r√†ng, minh b·∫°ch. N·∫øu c√≥ t·∫£i t√†i li·ªáu l√™n th√¨ khi s·ª≠ d·ª•ng th√¥ng tin trong t√†i li·ªáu n√†o ph·∫£i ƒë√°nh s·ªë tr√≠ch d·∫´n v√† cu·ªëi c√πng ph·∫£i cho danh m·ª•c t√†i li·ªáu ƒë√£ tham kh·∫£o theo AMA 11:
- P: ${p}
- I: ${i}
- C: ${c}
- O: ${o}

${fileText ? "\nT√†i li·ªáu ng∆∞·ªùi d√πng cung c·∫•p:\n" + fileText : ""}`;

  output.textContent = "‚è≥ ƒêang sinh n·ªôi dung t·ª´ GPT...";

  try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

async function evaluateGPT_NewMethods() {
  const inputText = document.getElementById('text-new-methods').value.trim();
  const output = document.getElementById('eval-new-methods');

  const prompt = `H√£y ƒë√°nh gi√° ƒëo·∫°n vƒÉn sau v·ªÅ *t√≠nh s√°ng t·∫°o, logic v√† ph√π h·ª£p* khi tr√¨nh b√†y c√°c ph∆∞∆°ng ph√°p ph√¢n t√≠ch m·ªõi ho·∫∑c c√°ch ƒë√°nh gi√° k·∫øt c·ª•c m·ªõi trong nghi√™n c·ª©u:
---
${inputText}`;

  output.textContent = "‚è≥ ƒêang ƒë√°nh gi√° n·ªôi dung...";

  try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

//B∆∞·ªõc 6
function updateDesignFields() {
  const type = document.getElementById("design-type").value;
  const container = document.getElementById("design-extra-fields");
  container.innerHTML = "";

  if (type === "parallel") {
    container.innerHTML = `
      <label>‚è±Ô∏è Th·ªùi gian can thi·ªáp (tu·∫ßn):</label>
      <input type="number" id="intervention-weeks" min="1" oninput="saveData()"><br><br>

      <label>üî¢ S·ªë nh√≥m can thi·ªáp:</label>
      <input type="number" id="num-arms" min="2" value="2" oninput="renderArms(); saveData()" style="width: 80px;"><br><br>

      <div id="arms-container"></div>
    `;
    renderArms(false); // kh√¥ng save li·ªÅn
  }

  else if (type === "cross-over") {
    container.innerHTML = `
      <label>‚è±Ô∏è Giai ƒëo·∫°n 1 (tu·∫ßn):</label>
      <input type="number" id="crossover-phase1" min="1" oninput="saveData()"><br><br>

      <label>üíâ Can thi·ªáp nh√≥m 1 ‚Äì Gƒê1:</label>
      <input type="text" id="crossover-g1-phase1" oninput="saveData()"><br><br>

      <label>üíâ Can thi·ªáp nh√≥m 2 ‚Äì Gƒê1:</label>
      <input type="text" id="crossover-g2-phase1" oninput="saveData()"><br><br>

      <label>üßº Th·ªùi gian r·ª≠a tr√¥i (washout, tu·∫ßn):</label>
      <input type="number" id="crossover-washout" min="1" oninput="saveData()"><br><br>
      
      <label>‚è±Ô∏è Giai ƒëo·∫°n 1 (tu·∫ßn):</label>
      <input type="number" id="crossover-phase1" min="1" oninput="saveData()"><br><br>

      <label>üíâ Can thi·ªáp nh√≥m 1 ‚Äì Gƒê2:</label>
      <input type="text" id="crossover-g1-phase2" oninput="saveData()"><br><br>

      <label>üíâ Can thi·ªáp nh√≥m 2 ‚Äì Gƒê2:</label>
      <input type="text" id="crossover-g2-phase2" oninput="saveData()"><br><br>
    `;

    // ƒê·∫£m b·∫£o c√≥ hidden num-arms = 2
    const input = document.createElement("input");
    input.type = "hidden";
    input.id = "num-arms";
    input.value = "2";
    container.appendChild(input);

    const div = document.createElement("div");
    div.id = "arms-container";
    container.appendChild(div);
  }

  saveData();
}

function renderArms(save = true) {
  const type = document.getElementById("design-type")?.value;
  if (type !== "parallel") return;  // ‚ùå Kh√¥ng l√†m g√¨ n·∫øu kh√¥ng ph·∫£i song song

  const num = parseInt(document.getElementById("num-arms").value) || 0;
  const container = document.getElementById("arms-container");
  if (!container) return;
  container.innerHTML = "";

  for (let i = 0; i < num; i++) {
    const div = document.createElement("div");
    div.innerHTML = `
      <label>Nh√≥m ${i + 1}:</label>
      <input type="text" class="arm-description" placeholder="T√™n nh√≥m / m√¥ t·∫£ ng·∫Øn" oninput="saveData()">
    `;
    container.appendChild(div);
  }

  if (save) saveData();
}

function updateNumArms() {
  const n = document.getElementById("num-arms").value;
  localStorage.setItem("num-arms", n);
  renderArms();
  saveData();
}

async function generateGPT_Design() {
  const p = document.getElementById("pico-p")?.value || "";
  const i = document.getElementById("pico-i")?.value || "";
  const c = document.getElementById("pico-c")?.value || "";
  const o = document.getElementById("pico-o")?.value || "";
  const mainObjective = document.getElementById("main-objective")?.value || "";

  const designType = document.getElementById("design-type").value;
  const randomization = document.getElementById("randomization").value;
  const blinding = document.getElementById("blinding").value;
  const file = document.getElementById("file-design").files[0];

  const phase1 = document.getElementById("crossover-phase1")?.value || "";
  const phase2 = document.getElementById("crossover-phase2")?.value || "";
  const washout = document.getElementById("crossover-washout")?.value || "";
  const interventionWeeks = document.getElementById("intervention-weeks")?.value || "";

  const output = document.getElementById("suggest-design");
  output.innerText = "‚è≥ GPT ƒëang sinh n·ªôi dung...";

  let fileText = "";
  if (file && file.type === "application/pdf") {
    try {
      fileText = await extractTextFromPDF(file);
    } catch (err) {
      console.error("L·ªói ƒë·ªçc PDF:", err);
    }
  }

  const designLabel = (designType === "parallel") ? "thi·∫øt k·∫ø song song" :
                      (designType === "cross-over") ? "thi·∫øt k·∫ø b·∫Øt ch√©o (cross-over)" :
                      "thi·∫øt k·∫ø ch∆∞a x√°c ƒë·ªãnh";

  const prompt = `${fileText ? "N·ªôi dung t·ª´ t√†i li·ªáu PDF:\n" + fileText + "\n\n" : ""}
D∆∞·ªõi ƒë√¢y l√† th√¥ng tin c·ªßa ƒë·ªÅ c∆∞∆°ng nghi√™n c·ª©u RCT:
- P: ${p}
- I: ${i}
- C: ${c}
- O: ${o}
- M·ª•c ti√™u ch√≠nh: ${mainObjective}
- Thi·∫øt k·∫ø ƒë∆∞·ª£c ch·ªçn: ${designLabel}
- Lo·∫°i ph√¢n b·ªï ng·∫´u nhi√™n: ${randomization}
- L√†m m√π: ${blinding}
- Th·ªùi gian can thi·ªáp: ${interventionWeeks || "ch∆∞a x√°c ƒë·ªãnh"}
${designType === "cross-over" ? `- Th·ªùi gian phase 1: ${phase1}
- Th·ªùi gian washout: ${washout}
- Th·ªùi gian phase 2: ${phase2}` : ""}

H√£y g·ª£i √Ω m·ªôt m√¥ t·∫£ ƒë·∫ßy ƒë·ªß v√† h·ª£p l√Ω cho ph·∫ßn Thi·∫øt k·∫ø nghi√™n c·ª©u. M√¥ t·∫£ c·∫ßn n√™u r√µ:
1. Thi·∫øt k·∫ø c√≥ ph√π h·ª£p v·ªõi m·ª•c ti√™u v√† b·ªánh l√Ω kh√¥ng?
2. Ph√¢n b·ªï ng·∫´u nhi√™n v√† l√†m m√π ch·ªçn c√≥ h·ª£p l√Ω kh√¥ng?
3. Th·ªùi gian can thi·ªáp c√≥ ƒë·ªß cho hi·ªáu qu·∫£ v√† washout (n·∫øu c√≥)?
4. N·∫øu thi·∫øt k·∫ø ch∆∞a t·ªëi ∆∞u, g·ª£i √Ω thay ƒë·ªïi t·ªët h∆°n.`;

try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

async function evaluateGPT_Design() {
  const desc = document.getElementById("suggest-design").innerText.trim();
  const p = document.getElementById("pico-p")?.value || "";
  const i = document.getElementById("pico-i")?.value || "";
  const c = document.getElementById("pico-c")?.value || "";
  const o = document.getElementById("pico-o")?.value || "";
  const mainObjective = document.getElementById("main-objective")?.value || "";

  const designType = document.getElementById("design-type").value;
  const randomization = document.getElementById("randomization").value;
  const blinding = document.getElementById("blinding").value;
  const interventionWeeks = document.getElementById("intervention-weeks")?.value || "";

  const phase1 = document.getElementById("crossover-phase1")?.value || "";
  const phase2 = document.getElementById("crossover-phase2")?.value || "";
  const washout = document.getElementById("crossover-washout")?.value || "";

  const output = document.getElementById("eval-design");
  output.innerText = "‚è≥ GPT ƒëang ƒë√°nh gi√°...";

  if (!desc) {
    alert("Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ ƒë√°nh gi√°.");
    return;
  }

  const prompt = `ƒê√¢y l√† ph·∫ßn m√¥ t·∫£ thi·∫øt k·∫ø nghi√™n c·ª©u RCT:\n"${desc}"\n\n
Th√¥ng tin ƒë·ªÅ c∆∞∆°ng li√™n quan:
- P: ${p}
- I: ${i}
- C: ${c}
- O: ${o}
- M·ª•c ti√™u ch√≠nh: ${mainObjective}
- Lo·∫°i thi·∫øt k·∫ø: ${designType}
- Ng·∫´u nhi√™n h√≥a: ${randomization}
- L√†m m√π: ${blinding}
- Th·ªùi gian can thi·ªáp: ${interventionWeeks}
${designType === "cross-over" ? `- Phase 1: ${phase1}
- Washout: ${washout}
- Phase 2: ${phase2}` : ""}

üëâ H√£y ƒë√°nh gi√°:
1. Thi·∫øt k·∫ø m√¥ t·∫£ c√≥ ph√π h·ª£p v·ªõi m·ª•c ti√™u nghi√™n c·ª©u kh√¥ng?
2. Lo·∫°i h√¨nh thi·∫øt k·∫ø c√≥ ph√π h·ª£p v·ªõi b·ªánh l√Ω v√† k·∫øt c·ª•c nghi√™n c·ª©u kh√¥ng?
3. C√°ch l√†m m√π, ph√¢n b·ªï ng·∫´u nhi√™n c√≥ h·ª£p l√Ω kh√¥ng?
4. Th·ªùi gian can thi·ªáp c√≥ ph√π h·ª£p v√† ƒë·ªß cho hi·ªáu qu·∫£ can thi·ªáp kh√¥ng?
5. N·∫øu c√≥ ƒëi·ªÉm ch∆∞a h·ª£p l√Ω, h√£y ch·ªâ r√µ v√† g·ª£i √Ω c√°ch c·∫£i thi·ªán.`;

try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

//B∆∞·ªõc 7

function renderSampleSizeForm() {
  const method = document.getElementById("sample-size-method").value;
  const form = document.getElementById("sample-size-form");
  const formula = document.getElementById("sample-size-formula");
  const reference = document.getElementById("sample-size-reference");

  form.innerHTML = "";
  formula.innerHTML = "";
  reference.innerHTML = "";

  if (!method) return;

  const alphaPowerHTML = `
    <label>Alpha:</label>
    <select id="alpha">
      <option value="0.05">0.05</option>
      <option value="0.01">0.01</option>
    </select>

    <label>Power:</label>
    <select id="power">
      <option value="0.80">80%</option>
      <option value="0.90">90%</option>
    </select>
    <br><br>
  `;

  const dropoutHTML = `
    <label>T·ª∑ l·ªá m·∫•t m·∫´u d·ª± ki·∫øn (%):</label>
    <input type="number" id="dropout-rate" step="1" min="0" max="100" oninput="checkDropoutWarning()">
    <span id="dropout-warning" style="color: red; font-weight: bold;"></span>
  `;

  let hasReference = false;

  if (method === "means") {
    form.innerHTML = `
      ${alphaPowerHTML}
      <label>ƒê·ªô l·ªách chu·∫©n (œÉ):</label>
      <input type="number" id="sigma" step="0.01">
      <label>Hi·ªáu s·ªë k·ª≥ v·ªçng (Œî):</label>
      <input type="number" id="delta" step="0.01">
      ${dropoutHTML}
    `;
    formula.innerHTML = `
      n = 2 √ó [(Z<sub>1‚àíŒ±/2</sub> + Z<sub>1‚àíŒ≤</sub>) √ó œÉ / Œî]<sup>2</sup>
    `;
    hasReference = true;

  } else if (method === "noninferiority_means") {
    form.innerHTML = `
      ${alphaPowerHTML}
      <label>Hi·ªáu s·ªë k·ª≥ v·ªçng (Œº<sub>T</sub> - Œº<sub>C</sub>):</label>
      <input type="number" id="delta-mean" step="0.01">
      <label>Bi√™n kh√¥ng k√©m h∆°n (Œî):</label>
      <input type="number" id="delta-margin" step="0.01">
      <label>ƒê·ªô l·ªách chu·∫©n (œÉ):</label>
      <input type="number" id="std-dev" step="0.01">
      ${dropoutHTML}
    `;
    formula.innerHTML = `
      n = 2 √ó (Z<sub>1‚àíŒ±</sub> + Z<sub>1‚àíŒ≤</sub>)<sup>2</sup> √ó œÉ<sup>2</sup> / (Œî ‚àí Œ¥)<sup>2</sup>
    `;
    hasReference = true;

  } else if (method === "proportions") {
    form.innerHTML = `
      ${alphaPowerHTML}
      <label>T·ª∑ l·ªá nh√≥m 1 (P‚ÇÅ):</label>
      <input type="number" id="p1" step="0.01" min="0" max="1">
      <label>T·ª∑ l·ªá nh√≥m 2 (P‚ÇÇ):</label>
      <input type="number" id="p2" step="0.01" min="0" max="1">
      ${dropoutHTML}
    `;
    formula.innerHTML = `
      n = [(Z<sub>1‚àíŒ±/2</sub>‚àö(2P(1‚àíP)) + Z<sub>1‚àíŒ≤</sub>‚àö(P‚ÇÅ(1‚àíP‚ÇÅ) + P‚ÇÇ(1‚àíP‚ÇÇ))]<sup>2</sup> / (P‚ÇÅ ‚àí P‚ÇÇ)<sup>2</sup><br>
      P = (P‚ÇÅ + P‚ÇÇ)/2
    `;
    hasReference = true;

  } else if (method === "noninferiority_prop") {
    form.innerHTML = `
      ${alphaPowerHTML}
      <label>T·ª∑ l·ªá nh√≥m ch·ª©ng (p<sub>C</sub>):</label>
      <input type="number" id="pc" step="0.01" min="0" max="1">
      <label>T·ª∑ l·ªá nh√≥m can thi·ªáp (p<sub>T</sub>):</label>
      <input type="number" id="pt" step="0.01" min="0" max="1">
      <label>Bi√™n kh√¥ng k√©m h∆°n (Œî):</label>
      <input type="number" id="delta-margin" step="0.01">
      ${dropoutHTML}
    `;
    formula.innerHTML = `
      n = [ (Z<sub>1‚àíŒ±</sub>‚àö(2pÃÑ(1‚àípÃÑ)) + Z<sub>1‚àíŒ≤</sub>‚àö(p<sub>C</sub>(1‚àíp<sub>C</sub>) + p<sub>T</sub>(1‚àíp<sub>T</sub>)) ]<sup>2</sup> / (p<sub>T</sub> ‚àí p<sub>C</sub> ‚àí Œî)<sup>2</sup>
    `;
    hasReference = true;

  } else if (method === "anova") {
    form.innerHTML = `
      ${alphaPowerHTML}
      <label>S·ªë nh√≥m (k):</label>
      <input type="number" id="k" min="2">
      <label>ƒê·ªô l·ªách chu·∫©n (œÉ):</label>
      <input type="number" id="sigma" step="0.01">
      <label>Hi·ªáu ·ª©ng mong mu·ªën (f):</label>
      <input type="number" id="effect-f" step="0.01">
      ${dropoutHTML}
    `;
    formula.innerHTML = `
      n = [(Z<sub>1‚àíŒ≤</sub> + Z<sub>1‚àíŒ±</sub>)<sup>2</sup> √ó (k ‚àí 1)] / (k √ó f<sup>2</sup>)
    `;
    hasReference = true;

  } else if (method === "chisq") {
    form.innerHTML = `
      ${alphaPowerHTML}
      <label>S·ªë nh√≥m (k):</label>
      <input type="number" id="k-chisq" min="2">
      <label>T·ª∑ l·ªá trung b√¨nh (P):</label>
      <input type="number" id="p-chisq" step="0.01" min="0" max="1">
      <label>Hi·ªáu ·ª©ng mong mu·ªën (w):</label>
      <input type="number" id="effect-w" step="0.01">
      ${dropoutHTML}
    `;
    formula.innerHTML = `
      n = (Z<sub>1‚àíŒ≤</sub> + Z<sub>1‚àíŒ±</sub>)<sup>2</sup> / w<sup>2</sup><br>
      w: ch·ªâ s·ªë hi·ªáu ·ª©ng Cohen (0.1 nh·ªè, 0.3 v·ª´a, 0.5 l·ªõn)
    `;
    hasReference = true;

  } else if (method === "survival") {
    form.innerHTML = `
      ${alphaPowerHTML}
      <label>T·ª∑ l·ªá s·ªëng nh√≥m ch·ª©ng (S‚ÇÄ):</label>
      <input type="number" id="s0" step="0.01" min="0" max="1">
      <label>T·ª∑ l·ªá s·ªëng nh√≥m can thi·ªáp (S‚ÇÅ):</label>
      <input type="number" id="s1" step="0.01" min="0" max="1">
      <label>Th·ªùi gian theo d√µi (t):</label>
      <input type="number" id="t" step="0.1" min="0">
      ${dropoutHTML}
    `;
    formula.innerHTML = `
      n = [ (Z<sub>1‚àíŒ±/2</sub> + Z<sub>1‚àíŒ≤</sub>)<sup>2</sup> √ó (1/S‚ÇÄ + 1/S‚ÇÅ) ] / (log(S‚ÇÅ) ‚àí log(S‚ÇÄ))<sup>2</sup>
    `;
    hasReference = true;

  } else if (method === "ancova") {
    form.innerHTML = `
      ${alphaPowerHTML}
      <label>Hi·ªáu s·ªë trung b√¨nh (Œî):</label>
      <input type="number" id="delta-mean" step="0.01">
      <label>ƒê·ªô l·ªách chu·∫©n (œÉ):</label>
      <input type="number" id="std-dev" step="0.01">
      <label>H·ªá s·ªë R<sup>2</sup>:</label>
      <input type="number" id="rsquared" step="0.01" min="0" max="1">
      ${dropoutHTML}
    `;
    formula.innerHTML = `
      n = 2 √ó (Z<sub>1‚àíŒ±</sub> + Z<sub>1‚àíŒ≤</sub>)<sup>2</sup> √ó œÉ<sup>2</sup> √ó (1 ‚àí R<sup>2</sup>) / Œî<sup>2</sup>
    `;
    hasReference = true;
 
 } else if (method === "crossover_means") {
    form.innerHTML = `
      ${alphaPowerHTML}
      <label>ƒê·ªô l·ªách chu·∫©n c·ªßa hi·ªáu s·ªë (œÉ<sub>d</sub>):</label>
      <input type="number" id="sigma_d" step="0.01">
      <label>Hi·ªáu s·ªë mong mu·ªën ph√°t hi·ªán (Œî):</label>
      <input type="number" id="delta_crossover" step="0.01">
      ${dropoutHTML}
    `;
    formula.innerHTML = `
      n = [(Z<sub>1‚àíŒ±/2</sub> + Z<sub>1‚àíŒ≤</sub>) √ó œÉ<sub>d</sub> / Œî]<sup>2</sup><br>
      (n l√† s·ªë ng∆∞·ªùi tham gia c·∫ßn thi·∫øt)
    `;
    hasReference = true;

  } else if (method === "crossover_props") {
    form.innerHTML = `
      ${alphaPowerHTML}
      <label>P<sub>10</sub> (x·∫£y ra ·ªü A, kh√¥ng ·ªü B):</label>
      <input type="number" id="p10" step="0.01" min="0" max="1">
      <label>P<sub>01</sub> (x·∫£y ra ·ªü B, kh√¥ng ·ªü A):</label>
      <input type="number" id="p01" step="0.01" min="0" max="1">
      ${dropoutHTML}
    `;
    formula.innerHTML = `
      n = [(Z<sub>1‚àíŒ±/2</sub> + Z<sub>1‚àíŒ≤</sub>)<sup>2</sup> √ó (P<sub>10</sub>(1 ‚àí P<sub>10</sub>) + P<sub>01</sub>(1 ‚àí P<sub>01</sub>))] / (P<sub>10</sub> ‚àí P<sub>01</sub>)<sup>2</sup>
    `;
    hasReference = true;
}
  if (hasReference) {
    reference.innerHTML = `Ngu·ªìn: Chow SC, Shao J, Wang H. <i>Sample Size Calculations in Clinical Research</i>. 3rd ed. CRC Press, 2018.`;
  }
}

function calculateSampleSize() {
  const method = document.getElementById("sample-size-method").value;
  const alpha = parseFloat(document.getElementById("alpha")?.value || "0.05");
  const power = parseFloat(document.getElementById("power")?.value || "0.8");
  const zAlpha = alpha === 0.01 ? 2.58 : 1.96;
  const zBeta = power === 0.9 ? 1.28 : 0.84;
  let n = 0;
  let resultText = "";

  if (method === "means") {
    const sigma = parseFloat(document.getElementById("sigma").value);
    const delta = parseFloat(document.getElementById("delta").value);
    n = 2 * Math.pow((zAlpha + zBeta) * sigma / delta, 2);
    resultText = `C·ª° m·∫´u m·ªói nh√≥m ‚âà <b>${Math.ceil(n)}</b>`;

  } else if (method === "proportions") {
    const p1 = parseFloat(document.getElementById("p1").value);
    const p2 = parseFloat(document.getElementById("p2").value);
    const p = (p1 + p2) / 2;
    const term1 = zAlpha * Math.sqrt(2 * p * (1 - p));
    const term2 = zBeta * Math.sqrt(p1 * (1 - p1) + p2 * (1 - p2));
    n = Math.pow(term1 + term2, 2) / Math.pow(p1 - p2, 2);
    resultText = `C·ª° m·∫´u m·ªói nh√≥m ‚âà <b>${Math.ceil(n)}</b>`;

  } else if (method === "anova") {
    const k = parseInt(document.getElementById("k").value);
    const f = parseFloat(document.getElementById("effect-f").value);
    n = ((zAlpha + zBeta) ** 2 * (k - 1)) / (k * f * f);
    resultText = `C·ª° m·∫´u m·ªói nh√≥m ‚âà <b>${Math.ceil(n)}</b>`;

  } else if (method === "chisq") {
    const w = parseFloat(document.getElementById("effect-w").value);
    n = Math.pow(zAlpha + zBeta, 2) / Math.pow(w, 2);
    resultText = `T·ªïng c·ª° m·∫´u c·∫ßn thi·∫øt ‚âà <b>${Math.ceil(n)}</b>`;

  } else if (method === "noninferiority_means") {
    const deltaObs = parseFloat(document.getElementById("delta-mean").value);
    const deltaMargin = parseFloat(document.getElementById("delta-margin").value);
    const std = parseFloat(document.getElementById("std-dev").value);
    const diff = deltaMargin - deltaObs;
    n = 2 * Math.pow((zAlpha + zBeta) * std / diff, 2);
    resultText = `C·ª° m·∫´u m·ªói nh√≥m ‚âà <b>${Math.ceil(n)}</b>`;

  } else if (method === "noninferiority_prop") {
    const pt = parseFloat(document.getElementById("pt").value);
    const pc = parseFloat(document.getElementById("pc").value);
    const delta = parseFloat(document.getElementById("delta-margin").value);
    const pbar = (pt + pc) / 2;
    const term1 = zAlpha * Math.sqrt(2 * pbar * (1 - pbar));
    const term2 = zBeta * Math.sqrt(pc * (1 - pc) + pt * (1 - pt));
    const diff = pt - pc - delta;
    n = Math.pow(term1 + term2, 2) / Math.pow(diff, 2);
    resultText = `C·ª° m·∫´u m·ªói nh√≥m ‚âà <b>${Math.ceil(n)}</b>`;

  } else if (method === "ancova") {
    const delta = parseFloat(document.getElementById("delta-mean").value);
    const sigma = parseFloat(document.getElementById("std-dev").value);
    const rsq = parseFloat(document.getElementById("rsquared").value);
    n = 2 * Math.pow(zAlpha + zBeta, 2) * sigma * sigma * (1 - rsq) / (delta * delta);
    resultText = `C·ª° m·∫´u m·ªói nh√≥m ‚âà <b>${Math.ceil(n)}</b>`;

  } else if (method === "survival") {
    const s0 = parseFloat(document.getElementById("s0").value);
    const s1 = parseFloat(document.getElementById("s1").value);
    const t = parseFloat(document.getElementById("t").value);
    const logDiff = Math.log(s1) - Math.log(s0);
    const term = (1 / s0 + 1 / s1);
    n = Math.pow(zAlpha + zBeta, 2) * term / Math.pow(logDiff, 2);
    resultText = `T·ªïng c·ª° m·∫´u c·∫ßn thi·∫øt ‚âà <b>${Math.ceil(n)}</b>`;

  } else if (method === "crossover_means") {
    const alpha = parseFloat(document.getElementById("alpha").value);
    const power = parseFloat(document.getElementById("power").value);
    const zAlpha = getZ(alpha / 2);
    const zBeta = getZ(1 - power);
    const sigma_d = parseFloat(document.getElementById("sigma_d").value);
    const delta = parseFloat(document.getElementById("delta_crossover").value);

    n = Math.pow((zAlpha + zBeta) * sigma_d / delta, 2);
    n = Math.ceil(n);

    resultText = `üìä Thi·∫øt k·∫ø b·∫Øt ch√©o ‚Äì So s√°nh trung b√¨nh:<br>
    C·ª° m·∫´u m·ªói nh√°nh c·∫ßn: <b>${n}</b> ng∆∞·ªùi`;

  } else if (method === "crossover_props") {
    const alpha = parseFloat(document.getElementById("alpha").value);
    const power = parseFloat(document.getElementById("power").value);
    const zAlpha = getZ(alpha / 2);
    const zBeta = getZ(1 - power);
    const p10 = parseFloat(document.getElementById("p10").value);
    const p01 = parseFloat(document.getElementById("p01").value);

    const numerator = Math.pow(zAlpha + zBeta, 2) * (p10 * (1 - p10) + p01 * (1 - p01));
    const denominator = Math.pow(p10 - p01, 2);

    n = numerator / denominator;
    n = Math.ceil(n);

    resultText = `üìâ Thi·∫øt k·∫ø b·∫Øt ch√©o ‚Äì So s√°nh t·ª∑ l·ªá:<br>
    C·ª° m·∫´u m·ªói nh√°nh c·∫ßn: <b>${n}</b> ng∆∞·ªùi`;
  } else {
    resultText = "üîß Ch∆∞a h·ªó tr·ª£ t√≠nh cho lo·∫°i c√¥ng th·ª©c n√†y.";
  }

  // Hi·ªÉn th·ªã k·∫øt qu·∫£ g·ªëc
  const resultDiv = document.getElementById("sample-size-result");
  resultDiv.innerHTML = resultText;

  // T√≠nh hi·ªáu ch·ªânh n·∫øu c√≥ dropout
  const dropoutRate = parseFloat(document.getElementById("dropout-rate")?.value || "0");
  const adjustedDiv = document.getElementById("sample-size-adjusted");
  if (!isNaN(n) && dropoutRate > 0 && dropoutRate < 100) {
    const nAdj = Math.ceil(n / (1 - dropoutRate / 100));
    adjustedDiv.innerHTML = `üéØ C·ª° m·∫´u hi·ªáu ch·ªânh sau khi t√≠nh m·∫•t m·∫´u ${dropoutRate}%: <b>${nAdj}</b>`;
    window.calculatedSampleSize = nAdj;
  } else {
    adjustedDiv.innerHTML = "";
    window.calculatedSampleSize = "";
 }
 saveData();
}

function checkDropoutWarning() {
  const val = parseFloat(document.getElementById("dropout-rate")?.value || 0);
  const warning = document.getElementById("dropout-warning");
  if (val > 10) {
    warning.textContent = "‚ö†Ô∏è Kh√¥ng n√™n m·∫•t m·∫´u qu√° 10% v√¨ c√≥ th·ªÉ ·∫£nh h∆∞·ªüng ƒë·∫øn ƒë·ªô tin c·∫≠y c·ªßa k·∫øt qu·∫£.";
  } else {
    warning.textContent = "";
  }
}

async function generateSampleSizeSuggestion() {
  const output = document.getElementById("suggest-sample-size");
  const fileInput = document.getElementById("file-sample-size");
  const file = fileInput.files[0];
  const method = document.getElementById("sample-size-method").value.trim();
  let fileText = "";

  if (file && file.type === "application/pdf") {
    output.textContent = "üìÑ ƒêang ƒë·ªçc file PDF...";
    fileText = await extractTextFromPDF(file);
  }

  const p = document.getElementById("pico-p").value.trim();
  const i = document.getElementById("pico-i").value.trim();
  const c = document.getElementById("pico-c").value.trim();
  const o = document.getElementById("pico-o").value.trim();
  const question = document.getElementById("question").value.trim();
  const mainObjective = document.getElementById("main-objective").value.trim();
  const subObjectives = Array.from(document.querySelectorAll(".sub-objective")).map(el => el.value.trim()).join("; ");

  const prompt = `D·ª±a v√†o c√°c th√¥ng tin sau, h√£y ƒë·ªÅ xu·∫•t c√°ch t√≠nh c·ª° m·∫´u ph√π h·ª£p (n√™u r√µ gi·∫£ ƒë·ªãnh, c√¥ng th·ª©c, th√¥ng s·ªë c·∫ßn thi·∫øt). N·∫øu c√≥ t·∫£i t√†i li·ªáu l√™n th√¨ ∆∞u ti√™n s·ª≠ d·ª•ng s·ªë li·ªáu c·∫ßn thi·∫øt cho t√≠nh c·ª° m·∫´u t·ª´ trong t√†i li·ªáu, v√† ph·∫£i b√°o c√°o v√†o cu·ªëi c√πng l√† s·ª≠ d·ª•ng t√†i li·ªáu n√†o ƒë·ªìng th·ªùi ph·∫£i cho danh m·ª•c t√†i li·ªáu ƒë√£ tham kh·∫£o theo AMA 11:

- P: ${p}
- I: ${i}
- C: ${c}
- O: ${o}
- C√¢u h·ªèi nghi√™n c·ª©u: ${question}
- M·ª•c ti√™u ch√≠nh: ${mainObjective}
- M·ª•c ti√™u ph·ª•: ${subObjectives}
- Ph∆∞∆°ng ph√°p ƒë·ªãnh tr∆∞·ªõc (n·∫øu c√≥): ${method}
${fileText ? "\nT√†i li·ªáu PDF ng∆∞·ªùi d√πng cung c·∫•p:\n" + fileText : ""}`;

  output.textContent = "‚è≥ ƒêang sinh g·ª£i √Ω t·ª´ GPT...";

  try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

async function evaluateSampleSize() {
  const output = document.getElementById("eval-sample-size");
  const method = document.getElementById("sample-size-method").value.trim();
  const alpha = document.getElementById("alpha")?.value || "";
  const power = document.getElementById("power")?.value || "";
  const dropout = document.getElementById("dropout-rate")?.value || "";

  const p = document.getElementById("pico-p").value.trim();
  const i = document.getElementById("pico-i").value.trim();
  const c = document.getElementById("pico-c").value.trim();
  const o = document.getElementById("pico-o").value.trim();
  const mainObjective = document.getElementById("main-objective").value.trim();

  let methodParams = "";

  // Thu th·∫≠p c√°c bi·∫øn ƒë·∫ßu v√†o tu·ª≥ lo·∫°i ph∆∞∆°ng ph√°p
  switch (method) {
    case "means":
      methodParams = `
      - ƒê·ªô l·ªách chu·∫©n (œÉ): ${document.getElementById("sigma").value}
      - Hi·ªáu s·ªë k·ª≥ v·ªçng (Œî): ${document.getElementById("delta").value}`;
      break;

    case "proportions":
      methodParams = `
      - T·ª∑ l·ªá nh√≥m 1 (P1): ${document.getElementById("p1").value}
      - T·ª∑ l·ªá nh√≥m 2 (P2): ${document.getElementById("p2").value}`;
      break;

    case "anova":
      methodParams = `
      - S·ªë nh√≥m: ${document.getElementById("k").value}
      - ƒê·ªô l·ªách chu·∫©n (œÉ): ${document.getElementById("sigma").value}
      - Hi·ªáu ·ª©ng f: ${document.getElementById("effect-f").value}`;
      break;

    case "chisq":
      methodParams = `
      - S·ªë nh√≥m (k): ${document.getElementById("k-chisq").value}
      - T·ª∑ l·ªá trung b√¨nh (P): ${document.getElementById("p-chisq").value}
      - Ch·ªâ s·ªë hi·ªáu ·ª©ng w: ${document.getElementById("effect-w").value}`;
      break;

    case "noninferiority_means":
      methodParams = `
      - Hi·ªáu s·ªë quan s√°t (ŒºT ‚àí ŒºC): ${document.getElementById("delta-mean").value}
      - Bi√™n kh√¥ng k√©m h∆°n (Œî): ${document.getElementById("delta-margin").value}
      - ƒê·ªô l·ªách chu·∫©n (œÉ): ${document.getElementById("std-dev").value}`;
      break;

    case "noninferiority_prop":
      methodParams = `
      - T·ª∑ l·ªá nh√≥m ch·ª©ng (pC): ${document.getElementById("pc").value}
      - T·ª∑ l·ªá nh√≥m can thi·ªáp (pT): ${document.getElementById("pt").value}
      - Bi√™n kh√¥ng k√©m h∆°n (Œî): ${document.getElementById("delta-margin").value}`;
      break;

    case "ancova":
      methodParams = `
      - Hi·ªáu s·ªë trung b√¨nh (Œî): ${document.getElementById("delta-mean").value}
      - ƒê·ªô l·ªách chu·∫©n (œÉ): ${document.getElementById("std-dev").value}
      - R b√¨nh ph∆∞∆°ng: ${document.getElementById("rsquared").value}`;
      break;
  }

  const prompt = `
Ng∆∞·ªùi d√πng ƒëang thi·∫øt k·∫ø nghi√™n c·ª©u v·ªõi th√¥ng tin nh∆∞ sau:
- P (Population): ${p}
- I (Intervention): ${i}
- C (Comparison): ${c}
- O (Outcome): ${o}
- M·ª•c ti√™u ch√≠nh: ${mainObjective}

C√¥ng th·ª©c t√≠nh c·ª° m·∫´u ƒë∆∞·ª£c ch·ªçn: ${method}
Th√¥ng s·ªë ƒë·∫ßu v√†o:
- Alpha: ${alpha}
- Power: ${power}
- Drop-out rate d·ª± ki·∫øn: ${dropout}%
${methodParams}

Y√™u c·∫ßu:
1. ƒê√°nh gi√° xem c√¥ng th·ª©c ch·ªçn c√≥ ph√π h·ª£p v·ªõi k·∫øt c·ª•c ch√≠nh (O), m·ª•c ti√™u v√† lo·∫°i thi·∫øt k·∫ø hay kh√¥ng.
2. Ph√¢n t√≠ch t·ª´ng th√¥ng s·ªë ƒë·∫ßu v√†o ƒë√£ h·ª£p l√Ω ch∆∞a (œÉ, Œî, p1/p2, R¬≤...), c√≥ ph√π h·ª£p v·ªõi gi√° tr·ªã th∆∞·ªùng g·∫∑p v√† c√≥ d·ª±a tr√™n b·∫±ng ch·ª©ng hay MCID kh√¥ng?
3. Drop-out rate nh∆∞ tr√™n c√≥ ·∫£nh h∆∞·ªüng nghi√™m tr·ªçng kh√¥ng?
4. N·∫øu c√≥ sai l·ªách ho·∫∑c ƒëi·ªÉm c·∫ßn c·∫£i thi·ªán, h√£y ch·ªâ r√µ v√† ƒë·ªÅ xu·∫•t ƒëi·ªÅu ch·ªânh.`.trim();

  output.textContent = "‚è≥ GPT ƒëang ph√¢n t√≠ch...";

try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

//B∆∞·ªõc 8

function addInclusionCriterion(text = "") {
  const div = document.createElement("div");
  div.innerHTML = `
    <input type="text" class="inclusion-item" value="${text}" placeholder="Nh·∫≠p ti√™u ch√≠ ch·ªçn..." oninput="saveData()">
    <button onclick="this.parentElement.remove(); saveData()">üóë</button>
  `;
  document.getElementById("inclusion-criteria").appendChild(div);
}

function addExclusionCriterion(text = "") {
  const div = document.createElement("div");
  div.innerHTML = `
    <input type="text" class="exclusion-item" value="${text}" placeholder="Nh·∫≠p ti√™u ch√≠ lo·∫°i..." oninput="saveData()">
    <button onclick="this.parentElement.remove(); saveData()">üóë</button>
  `;
  document.getElementById("exclusion-criteria").appendChild(div);
}

async function generateCriteriaFromGPT() {
  const output = document.getElementById("criteria-gpt-suggestion");
  output.innerText = "üîÑ ƒêang g·ª£i √Ω t·ª´ GPT...";

  const file = document.getElementById("file-criteria")?.files?.[0];
  let fileText = "";

  // ƒê·ªçc file PDF n·∫øu c√≥
  if (file && file.type === "application/pdf") {
    try {
      fileText = await extractTextFromPDF(file);
    } catch (err) {
      console.error("‚ùó L·ªói ƒë·ªçc PDF:", err);
    }
  }

  // Tr√≠ch xu·∫•t th√¥ng tin t·ª´ form
  const pico = {
    p: document.getElementById("pico-p")?.value || "",
    i: document.getElementById("pico-i")?.value || "",
    c: document.getElementById("pico-c")?.value || "",
    o: document.getElementById("pico-o")?.value || ""
  };

  const mainObjective = document.getElementById("main-objective")?.value || "";
  const subObjectives = Array.from(document.querySelectorAll(".sub-objective")).map(el => el.value).filter(v => v).join("; ");

  const interventions = Array.from(document.querySelectorAll(".arm-description")).map((el, i) => `Nh√≥m ${i + 1}: ${el.value}`).join("\n");

  const context = `
PICO:
- P (D√¢n s·ªë): ${pico.p}
- I (Can thi·ªáp): ${pico.i}
- C (So s√°nh): ${pico.c}
- O (K·∫øt c·ª•c): ${pico.o}

M·ª•c ti√™u ch√≠nh: ${mainObjective}
M·ª•c ti√™u ph·ª•: ${subObjectives}

M√¥ t·∫£ can thi·ªáp:
${interventions}
  `.trim();

  // T·∫°o prompt g·ª≠i GPT
  const prompt = `${fileText ? "T√†i li·ªáu PDF:\n" + fileText + "\n\n" : ""}
Th√¥ng tin t·ª´ c√°c b∆∞·ªõc tr∆∞·ªõc:
${context}

H√£y ƒë·ªÅ xu·∫•t c√°c ti√™u ch√≠ **ch·ªçn** v√† **lo·∫°i** ph√π h·ª£p cho m·ªôt nghi√™n c·ª©u RCT. Tr√¨nh b√†y r√µ r√†ng, ph√¢n bi·ªát r√µ hai nh√≥m ti√™u ch√≠. C·∫ßn n√™u r√µ l√Ω do t·∫°i sao c√≥ ti√™u ch√≠ ƒë√≥. C√¢n nh·∫Øc ƒë·∫øn t√≠nh ph√π h·ª£p v·ªõi b·ªánh/t√¨nh tr·∫°ng trong nghi√™n c·ª©u, c√°c ti√™u chu·∫©n th∆∞·ªùng ƒë∆∞·ª£c s·ª≠ d·ª•ng trong c√°c nghi√™n c·ª©u c√πng lo·∫°i, s·ª± ph√π h·ª£p v·ªõi m·ª•c ti√™u nghi√™n c·ª©u. N·∫øu c√≥ t·∫£i t√†i li·ªáu l√™n th√¨ khi s·ª≠ d·ª•ng th√¥ng tin trong t√†i li·ªáu n√†o ph·∫£i ƒë√°nh s·ªë tr√≠ch d·∫´n v√† cu·ªëi c√πng ph·∫£i cho danh m·ª•c t√†i li·ªáu ƒë√£ tham kh·∫£o theo AMA 11`;

try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

async function evaluateCriteria() {
  const output = document.getElementById("criteria-gpt-evaluation");
  output.innerText = "üîç ƒêang ƒë√°nh gi√°...";

  const inclusion = [...document.querySelectorAll("#inclusion-criteria input")]
    .map(e => e.value.trim()).filter(Boolean);
  const exclusion = [...document.querySelectorAll("#exclusion-criteria input")]
    .map(e => e.value.trim()).filter(Boolean);

  const criteriaText = `Ti√™u ch√≠ ch·ªçn:\n${inclusion.join("\n")}\n\nTi√™u ch√≠ lo·∫°i:\n${exclusion.join("\n")}`;

  const prompt = `H√£y ƒë√°nh gi√° c√°c ti√™u ch√≠ ch·ªçn v√† lo·∫°i sau cho nghi√™n c·ª©u RCT. 
Xem x√©t t√≠nh ph√π h·ª£p, c·ª• th·ªÉ, khoa h·ªçc v√† c√≥ lo·∫°i tr·ª´ ƒë·ªß c√°c y·∫øu t·ªë g√¢y nhi·ªÖu kh√¥ng. Th√™m ph·∫ßn gi·∫£i th√≠ch l√Ω do s·ª± ph√π h·ª£p c·ªßa t·ª´ng ti√™u ch√≠ v·ªõi nghi√™n c·ª©u n√†y:

${criteriaText}`;

try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

//B∆∞·ªõc 9

function renderRandomOptions() {
  const method = document.getElementById("random-method").value;
  const container = document.getElementById("random-options");
  container.innerHTML = "";

  if (method === "block") {
    container.innerHTML = `
      <label>K√≠ch th∆∞·ªõc block:</label>
      <input type="number" id="block-size" min="2" step="2" oninput="saveData()">
    `;
  } else if (method === "stratified") {
    container.innerHTML = `
      <label>Bi·∫øn ph√¢n t·∫ßng (v√≠ d·ª•: tu·ªïi, gi·ªõi):</label>
      <input type="text" id="strata-variables" placeholder="Nh·∫≠p t√™n bi·∫øn ph√¢n t·∫ßng, c√°ch nhau b·∫±ng d·∫•u ph·∫©y" oninput="saveData()">
    `;
  } else if (method === "adaptive") {
    container.innerHTML = `
      <label>Thu·∫≠t to√°n th√≠ch ·ª©ng:</label>
      <select id="adaptive-type" onchange="saveData()">
        <option value="minimization">Minimization</option>
        <option value="covariate">Covariate-Adaptive</option>
      </select>
    `;
  }
}

function loadRandomizationInfo() {
  // L·∫•y s·ªë nh√°nh can thi·ªáp t·ª´ b∆∞·ªõc 6 (thi·∫øt k·∫ø nghi√™n c·ª©u)
  const n = localStorage.getItem("num-arms");
  if (n) {
    document.getElementById("num-arms-step9").value = n;
  }
}

function generateAutoRandomization() {
  const method = document.getElementById("random-method").value;
  const arms = document.getElementById("num-arms-step9").value;
  let description = "";

  if (!method || !arms) return;

  switch (method) {
    case "simple":
      description = `Ph∆∞∆°ng ph√°p ng·∫´u nhi√™n ƒë∆°n gi·∫£n ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ ph√¢n b·ªï ng∆∞·ªùi tham gia v√†o ${arms} nh√≥m v·ªõi x√°c su·∫•t b·∫±ng nhau. Danh s√°ch ng·∫´u nhi√™n ƒë∆∞·ª£c t·∫°o ra b·∫±ng m√°y t√≠nh th√¥ng qua ph·∫ßn m·ªÅm th·ªëng k√™ (v√≠ d·ª•: R, Stata ho·∫∑c random.org) b·∫±ng c√°ch sinh chu·ªói s·ªë ng·∫´u nhi√™n kh√¥ng l·∫∑p. M·ªói ng∆∞·ªùi tham gia sau khi ƒë·ªß ti√™u chu·∫©n s·∫Ω ƒë∆∞·ª£c g√°n v√†o m·ªôt nh√≥m d·ª±a tr√™n th·ª© t·ª± xu·∫•t hi·ªán trong danh s√°ch ng·∫´u nhi√™n n√†y. Tr√¨nh t·ª± ph√¢n b·ªï ƒë∆∞·ª£c gi·ªØ k√≠n b·∫±ng phong b√¨ opaque, ƒë√°nh s·ªë th·ª© t·ª±, ni√™m phong, ch·ªâ ƒë∆∞·ª£c m·ªü khi ng∆∞·ªùi tham gia ƒë∆∞·ª£c ƒë∆∞a v√†o nghi√™n c·ª©u ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh che gi·∫•u ph√¢n nh√≥m.`;
      break;
    case "block":
      description = `Ph√¢n b·ªï ng·∫´u nhi√™n theo kh·ªëi ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ ƒë·∫£m b·∫£o s·ªë l∆∞·ª£ng ng∆∞·ªùi tham gia ƒë∆∞·ª£c ph√¢n b·ªë ƒë·ªÅu gi·ªØa ${arms} nh√≥m trong su·ªët qu√° tr√¨nh thu nh·∫≠n. C√°c kh·ªëi c√≥ k√≠ch th∆∞·ªõc c·ªë ƒë·ªãnh (v√≠ d·ª•: 4, 6 ho·∫∑c 8) ƒë∆∞·ª£c t·∫°o ra ng·∫´u nhi√™n b·∫±ng ph·∫ßn m·ªÅm th·ªëng k√™. Tr√¨nh t·ª± ph√¢n b·ªï trong m·ªói kh·ªëi ƒë∆∞·ª£c ho√°n v·ªã ng·∫´u nhi√™n ƒë·ªÉ tr√°nh d·ª± ƒëo√°n. Danh s√°ch to√†n b·ªô chu·ªói ph√¢n b·ªï theo kh·ªëi ƒë∆∞·ª£c t·∫°o tr∆∞·ªõc v√† l∆∞u gi·ªØ b·ªüi m·ªôt ng∆∞·ªùi th·ª© ba kh√¥ng tham gia v√†o vi·ªác thu nh·∫≠n. Tr√¨nh t·ª± ƒë∆∞·ª£c che gi·∫•u b·∫±ng h·ªá th·ªëng m√£ h√≥a ho·∫∑c phong b√¨ m√π, ƒë·∫£m b·∫£o ng∆∞·ªùi nghi√™n c·ª©u kh√¥ng bi·∫øt tr∆∞·ªõc nh√≥m ph√¢n b·ªï.`;
      break;
    case "stratified":
      description = `Ph∆∞∆°ng ph√°p ng·∫´u nhi√™n ph√¢n t·∫ßng ƒë∆∞·ª£c √°p d·ª•ng nh·∫±m ƒë·∫£m b·∫£o c√¢n b·∫±ng c√°c y·∫øu t·ªë n·ªÅn quan tr·ªçng (v√≠ d·ª•: gi·ªõi t√≠nh, ƒë·ªô tu·ªïi, m·ª©c ƒë·ªô b·ªánh) gi·ªØa ${arms} nh√≥m. C√°c t·∫ßng ph√¢n lo·∫°i ƒë∆∞·ª£c x√°c ƒë·ªãnh tr∆∞·ªõc khi ti·∫øn h√†nh ph√¢n b·ªï. Trong m·ªói t·∫ßng, ng∆∞·ªùi tham gia s·∫Ω ƒë∆∞·ª£c ph√¢n b·ªë v√†o c√°c nh√≥m th√¥ng qua ph∆∞∆°ng ph√°p ng·∫´u nhi√™n theo kh·ªëi ho·∫∑c ng·∫´u nhi√™n ƒë∆°n gi·∫£n, s·ª≠ d·ª•ng ph·∫ßn m·ªÅm chuy√™n d·ª•ng. Danh s√°ch ng·∫´u nhi√™n ƒë∆∞·ª£c t·∫°o ri√™ng cho t·ª´ng t·∫ßng v√† l∆∞u gi·ªØ b·ªüi ng∆∞·ªùi kh√¥ng tham gia thu nh·∫≠n ƒë·ªÉ ƒë·∫£m b·∫£o che gi·∫•u ph√¢n nh√≥m.`;
      break;
    case "minimization":
      description = `Ph∆∞∆°ng ph√°p ng·∫´u nhi√™n h√≥a t·ªëi thi·ªÉu (minimization) ƒë∆∞·ª£c √°p d·ª•ng ƒë·ªÉ t·ªëi ∆∞u h√≥a s·ª± c√¢n b·∫±ng gi·ªØa c√°c nh√≥m nghi√™n c·ª©u d·ª±a tr√™n c√°c y·∫øu t·ªë n·ªÅn (nh∆∞ gi·ªõi t√≠nh, ƒë·ªô tu·ªïi, m·ª©c ƒë·ªô b·ªánh). T·∫°i th·ªùi ƒëi·ªÉm ph√¢n b·ªï m·ªói ng∆∞·ªùi tham gia, ph·∫ßn m·ªÅm so s√°nh c√°c ƒë·∫∑c ƒëi·ªÉm c·ªßa ng∆∞·ªùi ƒë√≥ v·ªõi c√°c nh√≥m hi·ªán t·∫°i v√† g√°n v√†o nh√≥m sao cho s·ª± m·∫•t c√¢n ƒë·ªëi l√† nh·ªè nh·∫•t. M·ªôt y·∫øu t·ªë ng·∫´u nhi√™n (v√≠ d·ª•: x√°c su·∫•t 0,8) ƒë∆∞·ª£c t√≠ch h·ª£p ƒë·ªÉ tr√°nh ph√¢n b·ªï ho√†n to√†n mang t√≠nh quy·∫øt ƒë·ªãnh. Tr√¨nh t·ª± ph√¢n b·ªï ƒë∆∞·ª£c th·ª±c hi·ªán b·ªüi h·ªá th·ªëng ƒëi·ªán t·ª≠ ƒë·ªôc l·∫≠p ho·∫∑c ng∆∞·ªùi th·ª© ba, ƒë·∫£m b·∫£o che gi·∫•u ph√¢n nh√≥m.`;
      break;
  }

  document.getElementById("randomization-method").value = description;
  saveData();
}

async function generateRandomizationSuggestion() {
  const output = document.getElementById("randomization-gpt-suggestion");
  output.innerText = "üîÑ ƒêang t·∫°o g·ª£i √Ω t·ª´ GPT...";

  const saved = JSON.parse(localStorage.getItem("rctWizardData") || "{}");
  const method = document.getElementById("random-method").value || saved.design?.randomMethod || "Ch∆∞a ch·ªçn";
  const numArms = localStorage.getItem("num-arms") || "Ch∆∞a r√µ";

  const design = saved.design || {};
  const designType = design.type || "Ch∆∞a khai b√°o";

  let crossoverInfo = "";
  if (designType === "cross-over") {
    const cr = design.crossover || {};
    crossoverInfo = `
Thi·∫øt k·∫ø b·∫Øt ch√©o:
- Giai ƒëo·∫°n 1: ${cr.phase1 || "..."} tu·∫ßn
- R·ª≠a tr√¥i: ${cr.washout || "..."} tu·∫ßn
- Nh√≥m 1: Giai ƒëo·∫°n 1 = ${cr.g1_phase1 || "A"}, Giai ƒëo·∫°n 2 = ${cr.g1_phase2 || "B"}
- Nh√≥m 2: Giai ƒëo·∫°n 1 = ${cr.g2_phase1 || "B"}, Giai ƒëo·∫°n 2 = ${cr.g2_phase2 || "A"}
`;
  }

  const context = `
P: ${saved.pico?.p || ""}
I: ${saved.pico?.i || ""}
C: ${saved.pico?.c || ""}
O: ${saved.pico?.o || ""}
M·ª•c ti√™u ch√≠nh: ${saved.mainObjective || ""}
Thi·∫øt k·∫ø nghi√™n c·ª©u: ${designType}
${crossoverInfo}
`;

  const file = document.getElementById("file-randomization")?.files?.[0];
  let fileText = "";
  if (file && file.type === "application/pdf") {
    try {
      fileText = await extractTextFromPDF(file);
    } catch (err) {
      console.error("L·ªói ƒë·ªçc file PDF:", err);
    }
  }

  const prompt = `
T√¥i ƒëang x√¢y d·ª±ng m·ªôt nghi√™n c·ª©u RCT v·ªõi c√°c th√¥ng tin sau:
${context}
S·ªë nh√≥m can thi·ªáp: ${numArms}
Ph∆∞∆°ng ph√°p ph√¢n b·ªï ng·∫´u nhi√™n ƒë√£ ch·ªçn: ${method}
${fileText ? "T√†i li·ªáu PDF li√™n quan:\n" + fileText : ""}

H√£y m√¥ t·∫£ chi ti·∫øt c√°ch ng·∫´u nhi√™n h√≥a ph√π h·ª£p v·ªõi thi·∫øt k·∫ø nghi√™n c·ª©u n√†y (ƒë·∫£m b·∫£o nh∆∞ m√¥ t·∫£ trong c√°c ƒë·ªÅ c∆∞∆°ng nghi√™n c·ª©u RCT chu·∫©n m·ª±c v√† l√†m sao ƒë·ªÉ mang t√≠nh t√°i l·∫≠p ƒë∆∞·ª£c), g·ªìm:
- T√™n v√† lo·∫°i ph∆∞∆°ng ph√°p
- Quy tr√¨nh th·ª±c hi·ªán chi ti·∫øt, ƒë√∫ng chu·∫©n ƒë·ªÅ c∆∞∆°ng nghi√™n c·ª©u RCT
- ƒê·∫£m b·∫£o ·∫©n ph√¢n b·ªï (n·∫øu c√≥)
- Ph·∫ßn m·ªÅm ho·∫∑c thu·∫≠t to√°n n√™n s·ª≠ d·ª•ng
- ∆Øu nh∆∞·ª£c ƒëi·ªÉm (n·∫øu c√≥)
`;

try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

async function evaluateRandomization() {
  const output = document.getElementById("randomization-gpt-evaluation");
  output.innerText = "üîç ƒêang ƒë√°nh gi√° t·ª´ GPT...";

  const method = document.getElementById("random-method")?.value || "Ch∆∞a ch·ªçn";
  const numArms = document.getElementById("num-arms-step9")?.value || "Ch∆∞a r√µ";
  const userText = document.getElementById("randomization-method")?.value || "";

  const saved = JSON.parse(localStorage.getItem("rctWizardData") || "{}");
  const designType = saved.design?.type || "Ch∆∞a khai b√°o";
  const objective = saved.mainObjective || "";

  let crossoverInfo = "";
  if (designType === "cross-over") {
    const cr = saved.design?.crossover || {};
    crossoverInfo = `
Thi·∫øt k·∫ø b·∫Øt ch√©o:
- Giai ƒëo·∫°n 1: ${cr.phase1 || "..."} tu·∫ßn
- R·ª≠a tr√¥i: ${cr.washout || "..."} tu·∫ßn
- Nh√≥m 1: Giai ƒëo·∫°n 1 = ${cr.g1_phase1 || "A"}, Giai ƒëo·∫°n 2 = ${cr.g1_phase2 || "B"}
- Nh√≥m 2: Giai ƒëo·∫°n 1 = ${cr.g2_phase1 || "B"}, Giai ƒëo·∫°n 2 = ${cr.g2_phase2 || "A"}
`;
  }

  const prompt = `
B·∫°n l√† chuy√™n gia ƒë√°nh gi√° thi·∫øt k·∫ø nghi√™n c·ª©u RCT.

D∆∞·ªõi ƒë√¢y l√† th√¥ng tin nghi√™n c·ª©u:
- Thi·∫øt k·∫ø: ${designType}
- M·ª•c ti√™u ch√≠nh: ${objective}
- S·ªë nh√≥m: ${numArms}
- Ph∆∞∆°ng ph√°p ng·∫´u nhi√™n ƒë√£ ch·ªçn: ${method}
${crossoverInfo}

M√¥ t·∫£ do ng∆∞·ªùi d√πng vi·∫øt:
${userText}

H√£y ƒë√°nh gi√° ƒëo·∫°n m√¥ t·∫£ tr√™n c√≥ ƒë√°p ·ª©ng c√°c y√™u c·∫ßu khoa h·ªçc c·ªßa m·ªôt nghi√™n c·ª©u RCT kh√¥ng, g·ªìm:
- ƒê·ªß chi ti·∫øt
- ƒê√∫ng k·ªπ thu·∫≠t ng·∫´u nhi√™n h√≥a
- C√≥ ·∫©n ph√¢n b·ªï kh√¥ng
- Ph√π h·ª£p v·ªõi thi·∫øt k·∫ø nghi√™n c·ª©u
- C√≥ nguy c∆° sai l·ªách hay thi·∫øu s√≥t n√†o c·∫ßn s·ª≠a
`;

try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

//B∆∞·ªõc 10

function renderInterventionBlocks() {
  const container = document.getElementById("intervention-descriptions");
  container.innerHTML = "";

  const saved = JSON.parse(localStorage.getItem("rctWizardData") || "{}");
  const designType = saved.design?.type || "parallel";

  if (designType === "parallel") {
    const n = parseInt(localStorage.getItem("num-arms") || "0");
    const names = (saved.design?.arms || []).slice(0, n);

    for (let i = 0; i < n; i++) {
      const groupName = names[i] || `Nh√≥m ${i + 1}`;
      const textareaId = `intervention-desc-${i}`;
      const fileId = `file-intervention-${i}`;
      const suggestId = `suggest-intervention-${i}`;
      const evalId = `eval-intervention-${i}`;

      container.innerHTML += `
        <div class="intervention-block" style="border:1px solid #ccc; padding:10px; margin-bottom:20px;">
          <h3>${groupName}</h3>
          <textarea id="${textareaId}" rows="5" placeholder="Nh·∫≠p m√¥ t·∫£ can thi·ªáp nh√≥m n√†y..." oninput="saveData()"></textarea><br><br>
          <label>T·∫£i t√†i li·ªáu PDF h·ªó tr·ª£:</label>
          <input type="file" id="${fileId}" accept=".pdf"><br><br>
          <button onclick="generateGroupIntervention(${i})">üß† GPT g·ª£i √Ω m√¥ t·∫£ nh√≥m</button>
          <button onclick="evaluateGroupIntervention(${i})">üßê GPT ƒë√°nh gi√° m√¥ t·∫£</button>
          <div id="${suggestId}" style="margin-top:10px; background:#eef; padding:10px; white-space:pre-wrap; border:1px solid #99c;"></div>
          <div id="${evalId}" style="margin-top:10px; background:#efe; padding:10px; white-space:pre-wrap; border:1px solid #9c9;"></div>
        </div>
      `;
    }
  } else if (designType === "cross-over") {
    const descs = saved.design?.crossover || {};
    const blocks = [
      { label: "Giai ƒëo·∫°n 1 ‚Äì Nh√≥m 1", id: "desc-g1-phase1", value: descs.g1_phase1 || "" },
      { label: "Giai ƒëo·∫°n 1 ‚Äì Nh√≥m 2", id: "desc-g2-phase1", value: descs.g2_phase1 || "" },
      { label: "Giai ƒëo·∫°n 2 ‚Äì Nh√≥m 1", id: "desc-g1-phase2", value: descs.g1_phase2 || "" },
      { label: "Giai ƒëo·∫°n 2 ‚Äì Nh√≥m 2", id: "desc-g2-phase2", value: descs.g2_phase2 || "" }
    ];

    blocks.forEach((block, index) => {
      container.innerHTML += `
        <div class="intervention-block" style="border:1px solid #ccc; padding:10px; margin-bottom:20px;">
          <h3>${block.label}</h3>
          <textarea id="${block.id}" rows="5" placeholder="Nh·∫≠p m√¥ t·∫£ can thi·ªáp..." oninput="saveData()">${block.value}</textarea><br><br>
          <label>T·∫£i t√†i li·ªáu PDF h·ªó tr·ª£:</label>
          <input type="file" id="file-${block.id}" accept=".pdf"><br><br>
          <button onclick="generateCrossoverIntervention('${block.id}')">üß† GPT g·ª£i √Ω m√¥ t·∫£</button>
          <button onclick="evaluateCrossoverIntervention('${block.id}')">üßê GPT ƒë√°nh gi√° m√¥ t·∫£</button>
          <div id="suggest-${block.id}" style="margin-top:10px; background:#eef; padding:10px; white-space:pre-wrap; border:1px solid #99c;"></div>
          <div id="eval-${block.id}" style="margin-top:10px; background:#efe; padding:10px; white-space:pre-wrap; border:1px solid #9c9;"></div>
        </div>
      `;
    });
  }
}


async function generateGroupIntervention(index) {
  const data = JSON.parse(localStorage.getItem("rctWizardData") || "{}");
  const arms = data.design?.arms || [];
  const pico = data.pico || {};
  const groupName = arms[index] || `Nh√≥m ${index + 1}`;
  const fileInput = document.getElementById(`file-intervention-${index}`);
  const textareaId = `intervention-desc-${index}`;
  const resultDiv = document.getElementById(`suggest-intervention-${index}`);

  resultDiv.innerText = "ƒêang x·ª≠ l√Ω GPT...";

  let fileText = "";
  if (fileInput?.files?.[0]) {
    fileText = await extractTextFromPDF(fileInput.files[0]);
  }

  const prompt = `${fileText ? "N·ªôi dung t·ª´ t√†i li·ªáu:\n" + fileText + "\n\n" : ""}H√£y vi·∫øt m√¥ t·∫£ can thi·ªáp cho nh√≥m: ${groupName}, ph·∫£i chi ti·∫øt, r√µ r√†ng, minh b·∫°ch ƒë√∫ng chu·∫©n m·ªôt RCT ch·∫•t l∆∞·ª£ng cao, t·ªëi thi·ªÉu ph·∫£i c√≥ th·ªùi gian, t·∫ßn su·∫•t, c√°ch th·ª©c... trong nghi√™n c·ª©u c√≥ th√¥ng tin PICO nh∆∞ sau:\nP: ${pico.p}\nI: ${pico.i}\nC: ${pico.c}\nO: ${pico.o}. N·∫øu can thi·ªáp l√† ch√¢m c·ª©u th√¨ ph·∫£i n√™u r√µ c√¥ng th·ª©c thuy·ªát, c√°ch ch√¢m, th√¥ng s·ªë k·ªπ thu·∫≠t c·ªßa kim, v·ªã tr√≠ t·ª´ng huy·ªát. N·∫øu can thi·ªáp l√† d√πng thu·ªëc thang th√¨ ph·∫£i n√™u r√µ b√†i thu·ªëc g·ªìm nh·ªØng v·ªã thu·ªëc g√¨, li·ªÅu l∆∞·ª£ng m·ªói v·ªã bao nhi√™u, v·ªã thu·ªëc ƒë∆∞·ª£c cung c·∫•p b·ªüi ƒë∆°n v·ªã/c∆° quan n√†o, ti√™u chu·∫©n d∆∞·ª£c li·ªáu ƒë·∫°t ƒë∆∞·ª£c l√† g√¨. ƒê·∫£m b·∫£o ƒë·ªß th√¥ng tin can thi·ªáp ƒë·ªÉ c√≥ th·ªÉ t√°i l·∫≠p ƒë∆∞·ª£c. N·∫øu c√≥ t·∫£i t√†i li·ªáu l√™n th√¨ khi s·ª≠ d·ª•ng th√¥ng tin trong t√†i li·ªáu n√†o ph·∫£i ƒë√°nh s·ªë tr√≠ch d·∫´n v√† cu·ªëi c√πng ph·∫£i cho danh m·ª•c t√†i li·ªáu ƒë√£ tham kh·∫£o theo AMA 11.`;

try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

async function evaluateGroupIntervention(index) {
  const content = document.getElementById(`intervention-desc-${index}`).value.trim();
  const evalDiv = document.getElementById(`eval-intervention-${index}`);
  if (!content) {
    evalDiv.innerText = "Vui l√≤ng nh·∫≠p m√¥ t·∫£ ƒë·ªÉ ƒë√°nh gi√°.";
    return;
  }

  const prompt = `ƒê√¢y l√† m√¥ t·∫£ can thi·ªáp nh√≥m ${index + 1}. H√£y ƒë√°nh gi√° ch·∫•t l∆∞·ª£ng m√¥ t·∫£ n√†y (ƒë·ªß r√µ r√†ng, chi ti·∫øt, minh m·∫°ch ch∆∞a ƒë·ªÉ c√≥ th·ªÉ t√°i l·∫≠p ƒë∆∞·ª£c) trong nghi√™n c·ª©u RCT:\n\n${content}`;

  evalDiv.innerText = "GPT ƒëang ƒë√°nh gi√°...";

try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

async function generateCrossoverIntervention(id) {
  const textarea = document.getElementById(`crossover-desc-${id}`);
  const fileInput = document.getElementById(`file-crossover-${id}`);
  const suggestDiv = document.getElementById(`suggest-crossover-${id}`);

  suggestDiv.innerText = "üß† ƒêang sinh m√¥ t·∫£ t·ª´ GPT...";

  let fileText = "";
  if (fileInput?.files?.[0]) {
    const file = fileInput.files[0];
    const reader = new FileReader();
    const fileLoaded = new Promise(resolve => {
      reader.onload = () => resolve(reader.result);
    });
    reader.readAsText(file);
    fileText = await fileLoaded;
  }

  const data = JSON.parse(localStorage.getItem("rctWizardData") || "{}");
  const pico = data.pico || {};

  const prompt = `
B·∫°n ƒëang vi·∫øt m√¥ t·∫£ can thi·ªáp cho m·ªôt nghi√™n c·ª©u RCT thi·∫øt k·∫ø b·∫Øt ch√©o.

üìå PICO:
- D√¢n s·ªë (P): ${pico.p || "ch∆∞a c√≥"}
- Can thi·ªáp (I): ${pico.i || "ch∆∞a c√≥"}
- So s√°nh (C): ${pico.c || "ch∆∞a c√≥"}
- K·∫øt c·ª•c (O): ${pico.o || "ch∆∞a c√≥"}

üìå ƒê√¢y l√† m√¥ t·∫£ c·∫ßn cho √¥ s·ªë ${id} (${["Giai ƒëo·∫°n 1 ‚Äì Nh√≥m 1", "Giai ƒëo·∫°n 1 ‚Äì Nh√≥m 2", "Giai ƒëo·∫°n 2 ‚Äì Nh√≥m 1", "Giai ƒëo·∫°n 2 ‚Äì Nh√≥m 2"][id]})
${fileText ? "üìÑ T√†i li·ªáu h·ªó tr·ª£:\n" + fileText.slice(0, 1000) : "‚ùå Kh√¥ng c√≥ t√†i li·ªáu h·ªó tr·ª£"}

üëâ Vi·∫øt m√¥ t·∫£ ng·∫Øn g·ªçn, chi ti·∫øt v·ªÅ n·ªôi dung can thi·ªáp nh√≥m t∆∞∆°ng ·ª©ng.
`;

try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

async function evaluateCrossoverIntervention(id) {
  const textarea = document.getElementById(`crossover-desc-${id}`);
  const evalDiv = document.getElementById(`eval-crossover-${id}`);
  const content = textarea.value.trim();

  if (!content) {
    evalDiv.innerText = "‚ö†Ô∏è Ch∆∞a c√≥ n·ªôi dung ƒë·ªÉ ƒë√°nh gi√°.";
    return;
  }

  const prompt = `
ƒê√¢y l√† m√¥ t·∫£ can thi·ªáp trong nghi√™n c·ª©u RCT b·∫Øt ch√©o ‚Äì √¥ s·ªë ${id} (${["Giai ƒëo·∫°n 1 ‚Äì Nh√≥m 1", "Giai ƒëo·∫°n 1 ‚Äì Nh√≥m 2", "Giai ƒëo·∫°n 2 ‚Äì Nh√≥m 1", "Giai ƒëo·∫°n 2 ‚Äì Nh√≥m 2"][id]}):

"${content}"

üëâ ƒê√°nh gi√° theo c√°c ti√™u ch√≠:
1. M·ª•c ti√™u r√µ r√†ng kh√¥ng?
2. Quy tr√¨nh th·ª±c hi·ªán ƒë·ªß ch∆∞a?
3. T·∫ßn su·∫•t, th·ªùi l∆∞·ª£ng, h√¨nh th·ª©c can thi·ªáp c√≥ n√™u kh√¥ng?
4. C√≥ g√¨ c·∫ßn b·ªï sung?

Vi·∫øt ph·∫£n h·ªìi theo t·ª´ng ti√™u ch√≠.
`;

  evalDiv.innerText = "üßê GPT ƒëang ƒë√°nh gi√°...";

try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

//B∆∞·ªõc 11

function removeVariable(event, name, role) {
  event.stopPropagation(); // tr√°nh g√¢y drag
  const list = document.querySelector(`.variable-selected[data-role="${role}"]`);
  const item = [...list.querySelectorAll("li")].find(li => li.dataset.name === name);
  if (item) item.remove();
  selectedVariables[role] = [...list.querySelectorAll("li")].map(li => ({
    name: li.dataset.name,
    role: li.dataset.role,
    type: li.textContent.match(/\(([^)]+)\)/)?.[1] || ""
  }));
}


function addNewVariable() {
  const newVar = {
    name: document.getElementById("new-name").value.trim(),
    role: document.getElementById("new-role").value.trim(),
    type: document.getElementById("new-type").value.trim(),
    unit: document.getElementById("new-unit").value.trim(),
    time: document.getElementById("new-time").value.trim(),
    measure: document.getElementById("new-measure").value.trim(),
    definition: document.getElementById("new-definition").value.trim(),
    source: document.getElementById("new-source").value.trim(),
    format: document.getElementById("new-format").value.trim(),
    range: document.getElementById("new-range").value.trim(),
    mcid_or_cutoff: document.getElementById("new-mcid").value.trim()
  };

  if (!newVar.name || !newVar.role || !newVar.type) {
    alert("Ph·∫£i c√≥ √≠t nh·∫•t t√™n, vai tr√≤ v√† ki·ªÉu d·ªØ li·ªáu.");
    return;
  }

  allVariables.push(newVar);
  createVariableDragUI();
}

function exportVariables() {
  const csv = Papa.unparse(allVariables);
  const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.href = url;
  link.download = "updated_variables.csv";
  link.click();
}

async function suggestVariablesForRole(role) {
  const saved = JSON.parse(localStorage.getItem("rctWizardData") || "{}");
  const pico = saved.pico || {};
  const objective = saved.mainObjective || "";
  const interventions = saved.interventions || [];
  const fileInput = document.getElementById(`file-variable-${role}`);
  const output = document.getElementById(`suggest-variable-${role}`);
  output.innerText = "GPT ƒëang g·ª£i √Ω...";

  let fileText = "";
  if (fileInput?.files?.[0]) {
    fileText = await extractTextFromPDF(fileInput.files[0]);
  }

  const prompt = `
Th√¥ng tin nghi√™n c·ª©u RCT:
- P: ${pico.p || ""}
- I: ${pico.i || ""}
- C: ${pico.c || ""}
- O: ${pico.o || ""}
- M·ª•c ti√™u: ${objective}
- M√¥ t·∫£ can thi·ªáp: ${interventions.join("\n\n")}

Y√™u c·∫ßu: H√£y g·ª£i √Ω m·ªôt s·ªë bi·∫øn ph√π h·ª£p cho nh√≥m bi·∫øn "${role}" (theo ch·ª©c nƒÉng nghi√™n c·ª©u). ƒê∆∞a t√™n bi·∫øn v√† ng·∫Øn g·ªçn l√Ω do n√™n ƒë∆∞a v√†o.
${fileText ? `\nT√†i li·ªáu tham kh·∫£o:\n${fileText}` : ""}
`;

try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

async function evaluateVariablesForRole(role) {
  const list = document.querySelector(`.variable-list.variable-selected[data-role="${role}"]`);
  const items = [...list.querySelectorAll("li")];
  const output = document.getElementById(`eval-variable-${role}`);

  if (items.length === 0) {
    output.innerText = "‚ö†Ô∏è Ch∆∞a c√≥ bi·∫øn n√†o ƒë∆∞·ª£c ch·ªçn.";
    return;
  }

  const selected = items.map(li => li.textContent).join(", ");
  const saved = JSON.parse(localStorage.getItem("rctWizardData") || "{}");
  const pico = saved.pico || {};
  const objective = saved.mainObjective || "";
  const interventions = saved.interventions || [];

  const prompt = `
Th√¥ng tin nghi√™n c·ª©u RCT:
- P: ${pico.p || ""}
- I: ${pico.i || ""}
- C: ${pico.c || ""}
- O: ${pico.o || ""}
- M·ª•c ti√™u: ${objective}
- M√¥ t·∫£ can thi·ªáp: ${interventions.join("\n\n")}

C√°c bi·∫øn ƒë∆∞·ª£c ch·ªçn cho nh√≥m "${role}": ${selected}

H√£y ƒë√°nh gi√° xem nh√≥m bi·∫øn n√†y c√≥ ph√π h·ª£p v·ªõi m·ª•c ti√™u nghi√™n c·ª©u kh√¥ng? C√≥ thi·∫øu ho·∫∑c th·ª´a kh√¥ng? G·ª£i √Ω c·∫£i thi·ªán n·∫øu c√≥.
`;

  output.innerText = "GPT ƒëang ƒë√°nh gi√°...";

try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

//B∆∞·ªõc 12
async function generateCollectSuggestion() {
  const saved = JSON.parse(localStorage.getItem("rctWizardData") || "{}");
  const pico = saved.pico || {};
  const objective = saved.mainObjective || "";
  const interventions = saved.interventions || [];
  const designType = saved.design?.type || "";
  const followupWeeks = saved.design?.followup || "";
  const crossover = saved.design?.crossover || {};

  // Bi·∫øn ƒë√£ ch·ªçn t·ª´ b∆∞·ªõc 11
  const selected = selectedVariables || {};
  const variableList = Object.entries(selected).flatMap(([role, vars]) =>
    vars.map(v => `${v.name} (${role})`)
  ).join(", ");

  // Tr√≠ch vƒÉn b·∫£n t·ª´ PDF n·∫øu c√≥
  const fileInput = document.getElementById("file-collect-pdf");
  let fileText = "";
  if (fileInput?.files?.[0]) {
    fileText = await extractTextFromPDF(fileInput.files[0]);
  }

  // Prompt kh√°c nhau theo thi·∫øt k·∫ø
  let designInfo = "";
  if (designType === "cross-over") {
    designInfo = `
Thi·∫øt k·∫ø: Nghi√™n c·ª©u b·∫Øt ch√©o (cross-over)
- Giai ƒëo·∫°n 1: ${crossover.phase1 || "?"} tu·∫ßn
- R·ª≠a tr√¥i: ${crossover.washout || "?"} tu·∫ßn
- Giai ƒëo·∫°n 2: ${crossover.phase2 || "?"} tu·∫ßn
    `.trim();
  } else {
    designInfo = `Thi·∫øt k·∫ø: Song song; Th·ªùi gian theo d√µi: ${followupWeeks || "?"} tu·∫ßn`;
  }

  const prompt = `
Th√¥ng tin nghi√™n c·ª©u:
- P: ${pico.p || ""}
- I: ${pico.i || ""}
- C: ${pico.c || ""}
- O: ${pico.o || ""}
- M·ª•c ti√™u: ${objective}
- Thi·∫øt k·∫ø nghi√™n c·ª©u: ${designInfo}
- Can thi·ªáp: ${interventions.join("\n\n")}
- Bi·∫øn ƒë√£ ch·ªçn: ${variableList}

H√£y g·ª£i √Ω k·∫ø ho·∫°ch thu th·∫≠p d·ªØ li·ªáu, g·ªìm:
- Th·ªùi ƒëi·ªÉm thu
- Ai thu th·∫≠p
- D·ª•ng c·ª• ƒëo
- Ph√¢n lo·∫°i bi·∫øn theo nh√≥m (n·ªÅn, k·∫øt c·ª•c ch√≠nh, ph·ª•, an to√†n, trung gian...)

${fileText ? `T√†i li·ªáu h·ªó tr·ª£:\n${fileText}` : ""}
  `.trim();

  const output = document.getElementById("suggest-collect");
  output.innerText = "GPT ƒëang g·ª£i √Ω...";

try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

async function evaluateCollectDescription() {
  const saved = JSON.parse(localStorage.getItem("rctWizardData") || "{}");
  const pico = saved.pico || {};
  const objective = saved.mainObjective || "";
  const interventions = saved.interventions || [];
  const designType = saved.design?.type || "";
  const followupWeeks = saved.design?.followup || "";
  const crossover = saved.design?.crossover || {};

  const desc = document.getElementById("collect-desc").value;

  const selected = selectedVariables || {};
  const variableList = Object.entries(selected).flatMap(([role, vars]) =>
    vars.map(v => `${v.name} (${role})`)
  ).join(", ");

  let designInfo = "";
  if (designType === "cross-over") {
    designInfo = `
Thi·∫øt k·∫ø: Nghi√™n c·ª©u b·∫Øt ch√©o (cross-over)
- Giai ƒëo·∫°n 1: ${crossover.phase1 || "?"} tu·∫ßn
- R·ª≠a tr√¥i: ${crossover.washout || "?"} tu·∫ßn
- Giai ƒëo·∫°n 2: ${crossover.phase2 || "?"} tu·∫ßn
    `.trim();
  } else {
    designInfo = `Thi·∫øt k·∫ø: Song song; Th·ªùi gian theo d√µi: ${followupWeeks || "?"} tu·∫ßn`;
  }

  const prompt = `
Th√¥ng tin nghi√™n c·ª©u:
- P: ${pico.p || ""}
- I: ${pico.i || ""}
- C: ${pico.c || ""}
- O: ${pico.o || ""}
- M·ª•c ti√™u: ${objective}
- Thi·∫øt k·∫ø nghi√™n c·ª©u: ${designInfo}
- Can thi·ªáp: ${interventions.join("\n\n")}
- Bi·∫øn ƒë√£ ch·ªçn: ${variableList}

Ng∆∞·ªùi d√πng ƒë√£ m√¥ t·∫£ k·∫ø ho·∫°ch thu th·∫≠p d·ªØ li·ªáu nh∆∞ sau:
"${desc}"

H√£y ƒë√°nh gi√° n·ªôi dung n√†y v·ªÅ m·ª©c ƒë·ªô h·ª£p l√Ω, ƒë·∫ßy ƒë·ªß, kh·∫£ thi v√† g·ª£i √Ω c·∫£i thi·ªán n·∫øu c·∫ßn.
  `.trim();

  const output = document.getElementById("eval-collect");
  output.innerText = "GPT ƒëang ƒë√°nh gi√°...";

try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

//B∆∞·ªõc 13

async function generateAnalysisPlan() {
  const saved = JSON.parse(localStorage.getItem("rctWizardData") || "{}");
  const pico = saved.pico || {};
  const objective = saved.mainObjective || "";
  const interventions = saved.interventions || [];
  const numArms = parseInt(localStorage.getItem("num-arms") || "0");
  const designType = saved.design?.type || "Song song";

  const selected = selectedVariables || {};
  const variableList = Object.entries(selected).flatMap(([role, vars]) =>
    vars.map(v => `${v.name} (${role})`)
  ).join(", ");

  const fileInput = document.getElementById("file-analysis-pdf");
  let fileText = "";
  if (fileInput?.files?.[0]) {
    fileText = await extractTextFromPDF(fileInput.files[0]);
  }

  let designExplain = "";
  switch (designType) {
    case "B·∫Øt ch√©o (cross-over)":
      designExplain = "Thi·∫øt k·∫ø nghi√™n c·ª©u l√† b·∫Øt ch√©o (cross-over), do ƒë√≥ c·∫ßn ph√¢n t√≠ch theo t·ª´ng c√° th·ªÉ v·ªõi ki·ªÉm tra carry-over effect.";
      break;
    case "RCT c·ª•m":
      designExplain = "Thi·∫øt k·∫ø nghi√™n c·ª©u l√† c·ª•m (cluster RCT), c·∫ßn s·ª≠ d·ª•ng m√¥ h√¨nh h·ªìi quy ƒëa m·ª©c ho·∫∑c GEE.";
      break;
    case "Factorial":
      designExplain = "Thi·∫øt k·∫ø nghi√™n c·ª©u l√† factorial, c·∫ßn ph√¢n t√≠ch hi·ªáu ·ª©ng ch√≠nh v√† t∆∞∆°ng t√°c gi·ªØa c√°c y·∫øu t·ªë.";
      break;
    default:
      designExplain = "Thi·∫øt k·∫ø nghi√™n c·ª©u l√† song song (parallel RCT).";
  }

  const prompt = `
B·∫°n l√† chuy√™n gia ph√¢n t√≠ch s·ªë li·ªáu l√¢m s√†ng. H√£y vi·∫øt k·∫ø ho·∫°ch ph√¢n t√≠ch s·ªë li·ªáu (SAP) cho nghi√™n c·ª©u sau:

- P: ${pico.p || ""}
- I: ${pico.i || ""}
- C: ${pico.c || ""}
- O: ${pico.o || ""}
- M·ª•c ti√™u nghi√™n c·ª©u: ${objective}
- Thi·∫øt k·∫ø nghi√™n c·ª©u: ${designType}
- ${designExplain}
- S·ªë nh√≥m can thi·ªáp: ${numArms}
- M√¥ t·∫£ can thi·ªáp: ${interventions.join("\n\n")}
- C√°c bi·∫øn s·ªë ƒë√£ ch·ªçn: ${variableList}

Y√™u c·∫ßu: Vi·∫øt k·∫ø ho·∫°ch ph√¢n t√≠ch chu·∫©n m·ª±c, bao g·ªìm:
1. Ph√¢n t√≠ch m√¥ t·∫£ ban ƒë·∫ßu
2. Ph√¢n t√≠ch k·∫øt c·ª•c ch√≠nh
3. Ph√¢n t√≠ch k·∫øt c·ª•c ph·ª•
4. Ph√¢n t√≠ch bi·∫øn n·ªÅn v√† y·∫øu t·ªë g√¢y nhi·ªÖu
5. Ph√¢n t√≠ch an to√†n
6. Ph√¢n t√≠ch nh·∫°y c·∫£m (n·∫øu c·∫ßn)
7. Ki·ªÉm ƒë·ªãnh th·ªëng k√™ t∆∞∆°ng ·ª©ng
8. Ph∆∞∆°ng ph√°p x·ª≠ l√Ω missing data
9. Ph·∫ßn m·ªÅm v√† ti√™u ch√≠ th·ªëng k√™

${fileText ? `T√†i li·ªáu h·ªó tr·ª£:\n${fileText}` : ""}
`;

  const output = document.getElementById("suggest-analysis");
  output.innerText = "GPT ƒëang g·ª£i √Ω...";

try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

async function evaluateAnalysisPlan() {
  const saved = JSON.parse(localStorage.getItem("rctWizardData") || "{}");
  const pico = saved.pico || {};
  const objective = saved.mainObjective || "";
  const interventions = saved.interventions || [];
  const numArms = parseInt(localStorage.getItem("num-arms") || "0");
  const designType = saved.design?.type || "Song song";

  const desc = document.getElementById("analysis-desc").value;
  const selected = selectedVariables || {};
  const variableList = Object.entries(selected).flatMap(([role, vars]) =>
    vars.map(v => `${v.name} (${role})`)
  ).join(", ");

  const prompt = `
B·∫°n l√† chuy√™n gia ƒë√°nh gi√° ƒë·ªÅ c∆∞∆°ng nghi√™n c·ª©u. H√£y ƒë·ªçc n·ªôi dung sau v√† cho nh·∫≠n x√©t xem chi·∫øn l∆∞·ª£c ph√¢n t√≠ch c√≥ h·ª£p l√Ω kh√¥ng, c√≥ c·∫ßn b·ªï sung hay c·∫£i thi·ªán kh√¥ng.

Th√¥ng tin nghi√™n c·ª©u:
- P: ${pico.p || ""}
- I: ${pico.i || ""}
- C: ${pico.c || ""}
- O: ${pico.o || ""}
- M·ª•c ti√™u nghi√™n c·ª©u: ${objective}
- Thi·∫øt k·∫ø nghi√™n c·ª©u: ${designType}
- S·ªë nh√≥m can thi·ªáp: ${numArms}
- M√¥ t·∫£ can thi·ªáp: ${interventions.join("\n\n")}
- C√°c bi·∫øn s·ªë ƒë√£ ch·ªçn: ${variableList}

Chi·∫øn l∆∞·ª£c ph√¢n t√≠ch ng∆∞·ªùi d√πng ƒë√£ vi·∫øt:
"${desc}"

Y√™u c·∫ßu: Nh·∫≠n x√©t r√µ r√†ng v·ªÅ ƒëi·ªÉm m·∫°nh, ƒëi·ªÉm thi·∫øu s√≥t, v√† ƒë·ªÅ xu·∫•t ƒëi·ªÅu ch·ªânh n·∫øu c√≥.
`;

  const output = document.getElementById("eval-analysis");
  output.innerText = "GPT ƒëang ƒë√°nh gi√°...";

ctry {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

//B∆∞·ªõc 14

async function generateEthicsSection() {
  const saved = JSON.parse(localStorage.getItem("rctWizardData") || "{}");
  const pico = saved.pico || {};
  const objective = saved.mainObjective || "";
  const interventions = saved.interventions || [];
  const numArms = parseInt(localStorage.getItem("num-arms") || "0");

  // N·∫øu c√≥ file PDF
  const fileInput = document.getElementById("file-ethics-pdf");
  let fileText = "";
  if (fileInput?.files?.[0]) {
    fileText = await extractTextFromPDF(fileInput.files[0]);
  }

  const prompt = `
B·∫°n l√† chuy√™n gia ƒë·∫°o ƒë·ª©c nghi√™n c·ª©u. H√£y vi·∫øt ph·∫ßn "ƒê·∫°o ƒë·ª©c nghi√™n c·ª©u" cho m·ªôt ƒë·ªÅ c∆∞∆°ng RCT v·ªõi c√°c th√¥ng tin sau:

- P: ${pico.p || ""}
- I: ${pico.i || ""}
- C: ${pico.c || ""}
- O: ${pico.o || ""}
- M·ª•c ti√™u nghi√™n c·ª©u: ${objective}
- S·ªë nh√≥m can thi·ªáp: ${numArms}
- M√¥ t·∫£ can thi·ªáp: ${interventions.join("\n\n")}

N·ªôi dung ƒë·∫°o ƒë·ª©c c·∫ßn tr√¨nh b√†y:
1. Tu√¢n th·ªß c√°c chu·∫©n m·ª±c ƒë·∫°o ƒë·ª©c (Tuy√™n b·ªë Helsinki, GCP, quy ƒë·ªãnh ƒë·ªãa ph∆∞∆°ng‚Ä¶)
2. Tr√¨nh quy tr√¨nh xin √Ω ki·∫øn H·ªôi ƒë·ªìng ƒê·∫°o ƒë·ª©c
3. M√¥ t·∫£ l·∫•y ƒë·ªìng thu·∫≠n ng∆∞·ªùi tham gia
4. B·∫£o m·∫≠t v√† quy·ªÅn ri√™ng t∆∞
5. Quy·ªÅn r√∫t lui, theo d√µi an to√†n
6. Qu·∫£n l√Ω d·ªØ li·ªáu v√† b·∫£o l∆∞u h·ªì s∆°

${fileText ? `T√†i li·ªáu h·ªó tr·ª£:\n${fileText}` : ""}
`;

  const output = document.getElementById("suggest-ethics");
  output.innerText = "GPT ƒëang g·ª£i √Ω...";

try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

async function evaluateEthicsSection() {
  const desc = document.getElementById("ethics-desc").value;

  const prompt = `
B·∫°n l√† th√†nh vi√™n H·ªôi ƒë·ªìng ƒê·∫°o ƒë·ª©c nghi√™n c·ª©u. H√£y ƒë√°nh gi√° n·ªôi dung sau c√≥ ƒë·∫ßy ƒë·ªß v√† ƒë√∫ng nguy√™n t·∫Øc ƒë·∫°o ƒë·ª©c nghi√™n c·ª©u kh√¥ng. N·∫øu thi·∫øu, h√£y g√≥p √Ω c·ª• th·ªÉ:

"${desc}"
`;

  const output = document.getElementById("eval-ethics");
  output.innerText = "GPT ƒëang ƒë√°nh gi√°...";

try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

//B∆∞·ªõc 15

async function checkLogic() {
  const saved = JSON.parse(localStorage.getItem("rctWizardData") || "{}");
  const pico = saved.pico || {};
  const objective = saved.mainObjective || "";
  const interventions = saved.interventions || [];
  const numArms = localStorage.getItem("num-arms") || "Kh√¥ng x√°c ƒë·ªãnh";

  const selected = selectedVariables || {};
  const variableList = Object.entries(selected).flatMap(([role, vars]) =>
    vars.map(v => `${v.name} (${role})`)
  ).join(", ");

  const analysis = document.getElementById("analysis-desc")?.value || "";
  const ethics = document.getElementById("ethics-desc")?.value || "";

  const prompt = `
B·∫°n l√† chuy√™n gia ƒë√°nh gi√° ƒë·ªÅ c∆∞∆°ng RCT. H√£y ki·ªÉm tra t√≠nh nh·∫•t qu√°n v√† logic gi·ªØa c√°c ph·∫ßn sau:

- P: ${pico.p || ""}
- I: ${pico.i || ""}
- C: ${pico.c || ""}
- O: ${pico.o || ""}
- M·ª•c ti√™u nghi√™n c·ª©u: ${objective}
- S·ªë nh√≥m can thi·ªáp: ${numArms}
- M√¥ t·∫£ can thi·ªáp: ${interventions.join("\n\n")}
- Bi·∫øn s·ªë ƒë√£ ch·ªçn: ${variableList}
- M√¥ t·∫£ ph√¢n t√≠ch s·ªë li·ªáu: ${analysis}
- Ph·∫ßn ƒë·∫°o ƒë·ª©c nghi√™n c·ª©u: ${ethics}

H√£y n√™u r√µ:
1. C√≥ ph·∫ßn n√†o b·ªã thi·∫øu ho·∫∑c ch∆∞a ƒëi·ªÅn kh√¥ng?
2. C√≥ m√¢u thu·∫´n gi·ªØa c√°c ph·∫ßn kh√¥ng?
3. G√≥p √Ω c√°ch ch·ªânh s·ª≠a ƒë·ªÉ h·ª£p l√Ω v√† nh·∫•t qu√°n.

ƒê√°nh gi√° t·ªïng quan ƒë·ªÅ c∆∞∆°ng n√†y.

`;

  const output = document.getElementById("logic-check-result");
  output.innerText = "GPT ƒëang ki·ªÉm tra...";

try {
  const response = await fetch("https://gpt-api-19xu.onrender.com/gpt.php", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });

  const text = await response.text();

  try {
    const data = JSON.parse(text);
    const result = data.choices?.[0]?.message?.content || "GPT kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi.";
    output.textContent = result;
  } catch (e) {
    output.textContent = "‚ùå L·ªói x·ª≠ l√Ω JSON: " + text;
  }

} catch (error) {
  output.textContent = "‚ùå L·ªói khi g·ªçi GPT API: " + error.message;
}

//B∆∞·ªõc 16
function downloadMermaidPNG() {
  const target = document.getElementById("consort-mermaid");
  html2canvas(target).then(canvas => {
    const link = document.createElement("a");
    link.download = "consort_diagram.png";
    link.href = canvas.toDataURL();
    link.click();
  });
}

function renderStudyFlowDiagram() {
  const saved = JSON.parse(localStorage.getItem("rctWizardData") || "{}");

  // B∆∞·ªõc 6 ‚Äì Thi·∫øt k·∫ø
  const designType = saved.design?.type || "parallel";
  const arms = saved.design?.arms || ["Nh√≥m 1", "Nh√≥m 2"];
  const interventions = saved.interventions || [];
  const samplePerGroup = saved.sampleSize?.perGroup || "n=??";
  const crossover = saved.design?.crossover || {};
  const phase1Weeks = parseInt(crossover.phase1Weeks || "0");
  const washoutWeeks = parseInt(crossover.washout || "0");

  // B∆∞·ªõc 7‚Äì8 ‚Äì Ti√™u ch√≠
  const inclusion = (saved.criteria?.inclusion || []).slice(0, 2).join("; ");
  const exclusion = (saved.criteria?.exclusion || []).slice(0, 2).join("; ");

  // B∆∞·ªõc 11 ‚Äì Bi·∫øn v√† th·ªùi gian ƒëo
  const selected = saved.selectedVariables || {};
  const timeMap = {};
  for (const role in selected) {
  (selected[role] || []).forEach(v => {
    const varName = (v.name || "").trim();
    const timesRaw = (v.time || "").split(",").map(s => s.trim()).filter(Boolean);
    timesRaw.forEach(t => {
      if (!t || !varName) return;
      if (!timeMap[t]) timeMap[t] = [];
      if (!timeMap[t].includes(varName)) timeMap[t].push(varName);
    });
  });
}

  // T√°ch giai ƒëo·∫°n n·∫øu l√† crossover
  const phase1Times = [], phase2Times = [];
  if (designType === "cross-over") {
    Object.keys(timeMap).forEach(t => {
      const match = t.match(/Tu·∫ßn\s*(\d+)/i);
      if (match) {
        const week = parseInt(match[1]);
        if (week <= phase1Weeks) phase1Times.push(t);
        else if (week > phase1Weeks + washoutWeeks) phase2Times.push(t);
      }
    });
  }

  const getVarsAt = times => {
  const merged = {}; // key = time, value = list bi·∫øn

  times.forEach(t => {
    (timeMap[t] || []).forEach(v => {
      if (!merged[t]) merged[t] = new Set();
      merged[t].add(v);
    });
  });

  return Object.keys(merged)
    .sort((a, b) => {
      const n1 = parseInt(a.match(/\d+/)?.[0] || "0");
      const n2 = parseInt(b.match(/\d+/)?.[0] || "0");
      return n1 - n2;
    })
    .map(t => `üïí ${t}: ${[...merged[t]].join(", ")}`)
    .join("<br>") || "Ch∆∞a x√°c ƒë·ªãnh";
};

  // B·∫Øt ƒë·∫ßu Mermaid
  let diagram = `flowchart TD\n`;
  diagram += `  A["üìã Thu nh·∫≠n ng∆∞·ªùi b·ªánh<br>Ti√™u ch√≠ ch·ªçn: ${inclusion || "..."}<br>Ti√™u ch√≠ lo·∫°i: ${exclusion || "..."}"] --> B["üé≤ Ng·∫´u nhi√™n h√≥a (${designType})"]\n`;

  if (designType === "parallel") {
    arms.forEach((name, i) => {
      const C = `C${i}`;
      const D = `D${i}`;
      const E = `E${i}`;
      const intervention = interventions[i] || "Can thi·ªáp";
      const uniqueTimes = Object.keys(timeMap).filter(t => !!t);
      const timesBlock = getVarsAt(uniqueTimes);
      diagram += `  B --> ${C}["${name}<br>${intervention}<br>${samplePerGroup}"]\n`;
      diagram += `  ${C} --> ${D}["üìä Thu th·∫≠p d·ªØ li·ªáu:<br>${timesBlock}"]\n`;
      diagram += `  ${D} --> ${E}["üìà Ph√¢n t√≠ch k·∫øt qu·∫£ nh√≥m ${i + 1}"]\n`;
    });
    arms.forEach((_, i) => {
      diagram += `  E${i} --> F["üìù T·ªïng h·ª£p & b√°o c√°o k·∫øt qu·∫£"]\n`;
    });

  } else if (designType === "cross-over") {
    
    const g1_phase1 = crossover.g1_phase1?.trim() || "Ch∆∞a r√µ";
    const g2_phase1 = crossover.g2_phase1?.trim() || "Ch∆∞a r√µ";
    const g1_phase2 = crossover.g1_phase2?.trim() || "Ch∆∞a r√µ";
    const g2_phase2 = crossover.g2_phase2?.trim() || "Ch∆∞a r√µ";

    const phase1Block = getVarsAt(phase1Times);
    const phase2Block = getVarsAt(phase2Times);

    diagram += `  B --> C1["Nh√≥m 1<br>‚è±Ô∏è Giai ƒëo·∫°n 1 (${phase1Weeks} tu·∫ßn): ${g1_phase1}<br>${samplePerGroup}"]\n`;
    diagram += `  B --> C2["Nh√≥m 2<br>‚è±Ô∏è Giai ƒëo·∫°n 1 (${phase1Weeks} tu·∫ßn): ${g2_phase1}<br>${samplePerGroup}"]\n`;

    diagram += `  C1 --> D1["üìä Thu th·∫≠p d·ªØ li·ªáu giai ƒëo·∫°n 1:<br>${phase1Block}"]\n`;
    diagram += `  C2 --> D2["üìä Thu th·∫≠p d·ªØ li·ªáu giai ƒëo·∫°n 1:<br>${phase1Block}"]\n`;

    diagram += `  D1 --> E1["üßº R·ª≠a tr√¥i (${washoutWeeks} tu·∫ßn)"] --> F1["‚è±Ô∏è Giai ƒëo·∫°n 2: ${g1_phase2}"] --> G1["üìä Thu th·∫≠p d·ªØ li·ªáu giai ƒëo·∫°n 2:<br>${phase2Block}"]\n`;
    diagram += `  D2 --> E2["üßº R·ª≠a tr√¥i (${washoutWeeks} tu·∫ßn)"] --> F2["‚è±Ô∏è Giai ƒëo·∫°n 2: ${g2_phase2}"] --> G2["üìä Thu th·∫≠p d·ªØ li·ªáu giai ƒëo·∫°n 2:<br>${phase2Block}"]\n`;

    diagram += `  G1 --> H["üìà Ph√¢n t√≠ch k·∫øt qu·∫£"]\n`;
    diagram += `  G2 --> H\n`;
    diagram += `  H --> I["üìù T·ªïng h·ª£p & b√°o c√°o"]\n`;
  }

  // V·∫Ω l·∫°i
  const oldContainer = document.getElementById("studyflow-mermaid");
  const parent = oldContainer?.parentElement;
  if (oldContainer) oldContainer.remove();

  const newPre = document.createElement("pre");
  newPre.id = "studyflow-mermaid";
  newPre.className = "mermaid";
  newPre.textContent = diagram;
  newPre.style.padding = "20px";
  newPre.style.border = "1px solid #ccc";

  parent.insertBefore(newPre, parent.querySelector("br"));

  setTimeout(() => {
    try {
      mermaid.run();
    } catch (err) {
      newPre.innerHTML = `<pre style="color:red;">L·ªói Mermaid: ${err.message || err}</pre>`;
      console.error("Mermaid error", err, diagram);
    }
  }, 50);
}

// ====================== PH·∫¶N 2: H√†m x·ª≠ l√Ω d·ªØ li·ªáu ==================

function saveData() {
  const arms = Array.from(document.querySelectorAll(".arm-description")).map(el => el.value);
  localStorage.setItem("num-arms", arms.length);
  let ethics = {};
    if (
    document.getElementById("ethics-board") &&
    document.getElementById("ethics-approval-code") &&
    document.getElementById("ethics-date") &&
    document.getElementById("ethics-rights") &&
    document.getElementById("ethics-note")
    ) {
    ethics = {
    board: document.getElementById("ethics-board").value,
    approvalCode: document.getElementById("ethics-approval-code").value,
    date: document.getElementById("ethics-date").value,
    rights: document.getElementById("ethics-rights").value,
    note: document.getElementById("ethics-note").value
    };
  }
  const data = {
    // B∆∞·ªõc 1: PICO
    pico: {
      p: document.getElementById("pico-p").value,
      i: document.getElementById("pico-i").value,
      c: document.getElementById("pico-c").value,
      o: document.getElementById("pico-o").value
    },

    // B∆∞·ªõc 2: C√¢u h·ªèi nghi√™n c·ª©u
    question: document.getElementById("question").value,

    // B∆∞·ªõc 3: M·ª•c ti√™u nghi√™n c·ª©u
    mainObjective: document.getElementById("main-objective").value,
    subObjectives: Array.from(document.querySelectorAll(".sub-objective")).map(el => el.value),

    // B∆∞·ªõc 4: M·ªü ƒë·∫ßu (CaRS)
    introduction: {
      territory: document.getElementById("intro-territory")?.value || "",
      niche: document.getElementById("intro-niche")?.value || "",
      occupy: document.getElementById("intro-occupy")?.value || ""
    },

    // B∆∞·ªõc 5: T·ªïng quan t√†i li·ªáu
    literature: Array.from(document.querySelectorAll(".literature-section")).map(div => ({
      title: div.querySelector(".literature-title").value,
      content: div.querySelector(".literature-content").value
    })),

    // B∆∞·ªõc 6: Thi·∫øt k·∫ø nghi√™n c·ª©u
    design: {
    type: document.getElementById("design-type").value,  // s·∫Ω l√†: "parallel", "cross-over", "cluster", ho·∫∑c "factorial"
    randomization: document.getElementById("randomization").value,
    blinding: document.getElementById("blinding").value,
    followupWeeks: document.getElementById("followup-weeks")?.value || "",
    arms: Array.from(document.querySelectorAll(".arm-description")).map(el => el.value),
    interventionWeeks: document.getElementById("intervention-weeks")?.value || "",
    crossover: {
          g1_phase1: document.getElementById("crossover-g1-phase1")?.value || "",
          g2_phase1: document.getElementById("crossover-g2-phase1")?.value || "",
          washout: document.getElementById("crossover-washout")?.value || "",
          g1_phase2: document.getElementById("crossover-g1-phase2")?.value || "",
          g2_phase2: document.getElementById("crossover-g2-phase2")?.value || "",
          phase1Weeks: document.getElementById("crossover-phase1")?.value || "" 
        }
    },

    // B∆∞·ªõc 7: C·ª° m·∫´u
    sampleSize: {
      method: document.getElementById("sample-size-method")?.value || "",
      alpha: document.getElementById("alpha")?.value || "",
      power: document.getElementById("power")?.value || "",
      sigma: document.getElementById("sigma")?.value || "",
      delta: document.getElementById("delta")?.value || "",
      deltaMean: document.getElementById("delta-mean")?.value || "",
      deltaMargin: document.getElementById("delta-margin")?.value || "",
      stdDev: document.getElementById("std-dev")?.value || "",
      p1: document.getElementById("p1")?.value || "",
      p2: document.getElementById("p2")?.value || "",
      pc: document.getElementById("pc")?.value || "",
      pt: document.getElementById("pt")?.value || "",
      rsquared: document.getElementById("rsquared")?.value || "",
      k: document.getElementById("k")?.value || "",
      effectF: document.getElementById("effect-f")?.value || "",
      effectW: document.getElementById("effect-w")?.value || "",
      kChisq: document.getElementById("k-chisq")?.value || "",
      pChisq: document.getElementById("p-chisq")?.value || "",
      perGroup: window.calculatedSampleSize || ""
    },

    // B∆∞·ªõc 8: Ti√™u ch√≠ ch·ªçn v√† lo·∫°i
    criteria: {
      inclusion: Array.from(document.querySelectorAll(".inclusion-item")).map(el => el.value),
      exclusion: Array.from(document.querySelectorAll(".exclusion-item")).map(el => el.value)
    },

    // B∆∞·ªõc 9: Ph√¢n b·ªï ng·∫´u nhi√™n
    randomization: {
      method: document.getElementById("random-method")?.value || "",
      blockSize: document.getElementById("block-size")?.value || "",
      strata: document.getElementById("strata-variables")?.value || "",
      adaptive: document.getElementById("adaptive-type")?.value || ""
    },

    // B∆∞·ªõc 10: Can thi·ªáp
    interventions: Array.from(document.querySelectorAll(".intervention-item")).map(el => el.value),

    // B∆∞·ªõc 11: Bi·∫øn s·ªë
    selectedVariables: (() => {
  const result = {};
  document.querySelectorAll(".variable-selected").forEach(list => {
    const role = list.dataset.role;
    const vars = Array.from(list.querySelectorAll("li")).map(li => ({
      name: li.dataset.name,
      role: li.dataset.role,
      type: li.dataset.type || "",
      time: li.dataset.time || "",
      unit: li.dataset.unit || "",
      measure: li.dataset.measure || "",
      definition: li.dataset.definition || "",
      source: li.dataset.source || "",
      format: li.dataset.format || "",
      range: li.dataset.range || "",
      mcid_or_cutoff: li.dataset.mcid || ""
    }));
    result[role] = vars;
  });
  window.selectedVariables = result;  
  return result;
 })(),

    // B∆∞·ªõc 12: Thu th·∫≠p s·ªë li·ªáu
    collectPlans: Array.from(document.querySelectorAll(".collection-block")).map(div => ({
      time: div.querySelector(".collect-time").value,
      variables: div.querySelector(".collect-variables").value,
      method: div.querySelector(".collect-method").value,
      by: div.querySelector(".collect-by").value,
      note: div.querySelector(".collect-note").value
    })),

    // B∆∞·ªõc 13: Ph√¢n t√≠ch s·ªë li·ªáu
    analysisPlans: Array.from(document.querySelectorAll(".analysis-block")).map(div => ({
      variable: div.querySelector(".analysis-variable").value,
      method: div.querySelector(".analysis-method").value,
      software: div.querySelector(".analysis-software").value,
      threshold: div.querySelector(".analysis-threshold").value,
      note: div.querySelector(".analysis-note").value
    })),

    // B∆∞·ªõc 14: ƒê·∫°o ƒë·ª©c nghi√™n c·ª©u
    
      ethics: ethics
    };
   localStorage.setItem("rctWizardData", JSON.stringify(data));
}


function loadData() {
  let data = JSON.parse(localStorage.getItem("rctWizardData"));
  if (!data) data = {};
  if (!data.pico) data.pico = {};

  // B∆∞·ªõc 1: PICO
  document.getElementById("pico-p").value = data.pico.p || "";
  document.getElementById("pico-i").value = data.pico.i || "";
  document.getElementById("pico-c").value = data.pico.c || "";
  document.getElementById("pico-o").value = data.pico.o || "";

  // B∆∞·ªõc 2: C√¢u h·ªèi
  document.getElementById("question").value = data.question || "";

  // B∆∞·ªõc 3: M·ª•c ti√™u
  document.getElementById("main-objective").value = data.mainObjective || "";
  const container = document.getElementById("sub-objectives");
  container.innerHTML = "";
  (data.subObjectives || []).forEach(val => {
    const div = document.createElement("div");
    div.innerHTML = `<input type="text" class="sub-objective" value="${val}">`;
    container.appendChild(div);
  });

  // B∆∞·ªõc 4: M·ªü ƒë·∫ßu
  if (data.introduction) {
    document.getElementById("intro-territory").value = data.introduction.territory || "";
    document.getElementById("intro-niche").value = data.introduction.niche || "";
    document.getElementById("intro-occupy").value = data.introduction.occupy || "";
  }

  // B∆∞·ªõc 5: T·ªïng quan t√†i li·ªáu
  if (data.literature && Array.isArray(data.literature)) {
  const container = document.getElementById("literature-sections");
  if (container) {
    container.innerHTML = "";
    data.literature.forEach(sec => addLiteratureSection(sec.title, sec.content));
  }
}

  // B∆∞·ªõc 6: Thi·∫øt k·∫ø nghi√™n c·ª©u
  if (data.design) {
  const typeEl = document.getElementById("design-type");
  if (typeEl) {
    typeEl.value = data.design.type || "";
    updateDesignFields();
  }

  const randEl = document.getElementById("randomization");
  if (randEl) randEl.value = data.design.randomization || "";

  const blindEl = document.getElementById("blinding");
  if (blindEl) blindEl.value = data.design.blinding || "";

  const followupEl = document.getElementById("followup-weeks");
  if (followupEl) followupEl.value = data.design.followupWeeks || "";

  const numArmsEl = document.getElementById("num-arms");
  if (numArmsEl) numArmsEl.value = data.design.arms?.length || 2;

  renderArms();

  const armsInputs = document.querySelectorAll(".arm-description");
  (data.design.arms || []).forEach((desc, idx) => {
    if (armsInputs[idx]) armsInputs[idx].value = desc;
  });
}

  // B∆∞·ªõc 7: C·ª° m·∫´u
  if (data.sampleSize) {
    document.getElementById("sample-size-method").value = data.sampleSize.method || "";
    renderSampleSizeForm();
    const f = (id, val) => { const el = document.getElementById(id); if (el) el.value = val || ""; };
    f("alpha", data.sampleSize.alpha);
    f("power", data.sampleSize.power);
    f("sigma", data.sampleSize.sigma);
    f("delta", data.sampleSize.delta);
    f("delta-mean", data.sampleSize.deltaMean);
    f("delta-margin", data.sampleSize.deltaMargin);
    f("std-dev", data.sampleSize.stdDev);
    f("p1", data.sampleSize.p1);
    f("p2", data.sampleSize.p2);
    f("pt", data.sampleSize.pt);
    f("pc", data.sampleSize.pc);
    f("rsquared", data.sampleSize.rsquared);
    f("k", data.sampleSize.k);
    f("effect-f", data.sampleSize.effectF);
    f("effect-w", data.sampleSize.effectW);
    f("k-chisq", data.sampleSize.kChisq);
    f("p-chisq", data.sampleSize.pChisq);
  }

  // B∆∞·ªõc 8: Ti√™u ch√≠
  if (data.criteria) {
    const inclusionBox = document.getElementById("inclusion-criteria");
    const exclusionBox = document.getElementById("exclusion-criteria");
    inclusionBox.innerHTML = "";
    exclusionBox.innerHTML = "";
    (data.criteria.inclusion || []).forEach(item => addInclusionCriterion(item));
    (data.criteria.exclusion || []).forEach(item => addExclusionCriterion(item));
  }

  // B∆∞·ªõc 9: Ph√¢n b·ªï ng·∫´u nhi√™n
  if (data.randomization) {
  const randomMethodEl = document.getElementById("random-method");
  if (randomMethodEl) {
    randomMethodEl.value = data.randomization.method || "";
    renderRandomOptions();

    if (data.randomization.blockSize) {
      const el = document.getElementById("block-size");
      if (el) el.value = data.randomization.blockSize;
    }

    if (data.randomization.strata) {
      const el = document.getElementById("strata-variables");
      if (el) el.value = data.randomization.strata;
    }

    if (data.randomization.adaptive) {
      const el = document.getElementById("adaptive-type");
      if (el) el.value = data.randomization.adaptive;
    }
  }
}

  // B∆∞·ªõc 10: M√¥ t·∫£ can thi·ªáp
  if (data.interventions && Array.isArray(data.interventions)) {
    const container = document.getElementById("intervention-descriptions");
    container.innerHTML = "";
    data.interventions.forEach(text => addIntervention(text));
  }

  // B∆∞·ªõc 11: Bi·∫øn s·ªë
  if (data.selectedVariables) {
    Object.entries(data.selectedVariables).forEach(([role, vars]) => {
      selectedVariables[role] = vars;
    });
    if (typeof createVariableDragUI === 'function') createVariableDragUI();
  }

  // B∆∞·ªõc 14: ƒê·∫°o ƒë·ª©c
  if (data.ethics && typeof data.ethics === "string") {
  document.getElementById("ethics-desc").value = data.ethics;
  }
}

// ====================== PH·∫¶N 3: H√†m ƒëi·ªÅu h∆∞·ªõng =====================

let currentStep = 0;
function goToStep(step) {
      document.querySelectorAll('.step').forEach((el, i) => {
        el.classList.toggle('active', i === step);
      });
      document.querySelectorAll('.steps-nav button').forEach((btn, i) => {
        btn.classList.toggle('active', i === step);
      });
      currentStep = step;
      localStorage.setItem("currentStep", step);
      if (step === 8) loadRandomizationInfo();
      if (step === 9) renderInterventionBlocks();
      if (step === 10) createVariableDragUI();
      if (step === 14) {
      const logicResult = document.getElementById("logic-check-result");
      if (logicResult) logicResult.innerHTML = "";
      };
      if (step === 15) renderStudyFlowDiagram();
    }

window.addEventListener('load', function () {
  const savedStep = parseInt(localStorage.getItem("currentStep")) || 0;
  goToStep(savedStep);  
  loadData();
  loadRandomizationInfo();
  renderSampleSizeForm();
  renderRandomOptions();

  if (typeof createVariableDragUI === 'function') createVariableDragUI();
  if (typeof updateDropdowns === 'function') updateDropdowns();
  if (typeof loadCSVFiles === 'function') loadCSVFiles();
  if (typeof setupPdfUpload === 'function') setupPdfUpload();
  if (typeof renderStudyFlowDiagram === "function") renderStudyFlowDiagram();
  if (typeof updateDesignFields === 'function') updateDesignFields();
});

function resetWizard() {
  if (confirm("B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô d·ªØ li·ªáu v√† l√†m l·∫°i t·ª´ ƒë·∫ßu?")) {
    localStorage.removeItem("rctWizardData");
    localStorage.removeItem("num-arms");
    location.reload();
  }
}

 window.addEventListener("DOMContentLoaded", function () {
    document.querySelectorAll("textarea, input[type='text']").forEach(el => {
      el.setAttribute("spellcheck", "false");
    });
  });

window.addEventListener("DOMContentLoaded", function () {
    const inputs = document.querySelectorAll("input, textarea, select");
    inputs.forEach(el => {
      el.addEventListener("input", () => {
        saveData();
      });
    });
  });

</script>
<footer style="margin-top: 50px; padding: 20px; text-align: center; font-size: 14px; color: #666; border-top: 1px solid #ccc;">
  ·ª®ng d·ª•ng n√†y ƒë∆∞·ª£c thi·∫øt k·∫ø b·ªüi <strong>V√µ Thanh Phong</strong> v·ªõi s·ª± h·ªó tr·ª£ t·ª´ <strong>ChatGPT</strong>.<br>
  B·∫£n quy·ªÅn thu·ªôc v·ªÅ <strong>V√µ Thanh Phong</strong> ‚Äì M·ªçi quy·ªÅn ƒë∆∞·ª£c b·∫£o l∆∞u.<br>
  Li√™n h·ªá: <a href="mailto:phongvanltk@gmail.com">phongvanltk@gmail.com</a>
</footer>
</body>
</html>



